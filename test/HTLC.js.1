const TokenManagerProxy         = artifacts.require('TokenManagerProxy');
const TokenManagerDelegate      = artifacts.require('TokenManagerDelegate');

const QuotaDelegate             = artifacts.require('QuotaDelegate.sol');
const QuotaProxy                = artifacts.require('QuotaProxy.sol');

const OracleDelegate            = artifacts.require('OracleDelegate.sol');
const OracleProxy               = artifacts.require('OracleProxy.sol');

const Bn128SchnorrVerifier      = artifacts.require('Bn128SchnorrVerifier.sol');
const Secp256k1SchnorrVerifier  = artifacts.require('Secp256k1SchnorrVerifier.sol');
const SignatureVerifier         = artifacts.require('SignatureVerifier.sol');

const CrossDelegate             = artifacts.require('CrossDelegate.sol');
const CrossProxy                = artifacts.require('CrossProxy.sol');

const TestStoremanAdmin         = artifacts.require('TestStoremanAdmin.sol');
const TestOrigTokenCreator      = artifacts.require("TestOrigTokenCreator.sol")

const { assert }                = require('chai');
const schnorr                   = require('../utils/schnorr/tools');
const {
    sleep,
    stringToBytes,
    getBalance,
    getRC20TokenInstance,
    getRC20TokenBalance,
    toNonExponential
}                               = require('./utils');

const {
    xInfo,
    skInfo
}                               = require('./config');

const BN                        = web3.utils.BN;

// let smgInstProxy, htlcInstProxy,tmInstProxy;
// let smgInst, htlcInst,tmInst;
// let crossDelegateNotInit;

// let revokeFeeRatio          = 100;
// let ratioPrecise            = 10000;
// let ratioPreciseInvld       = 10001;
// let lockedTime              = 40*1000; //unit: ms
// let msgRcvTimeout           = 40*1000; //unit: ms
// let DEFAULT_PRECISE         = 10000;


// let tokenInfo       = {
//   decimals              : 18,
//   tokenOrigAccount      : web3.utils.asciiToHex('Eos contract address'),
//   token2WanRatio        : 10000,                  // 1:1
//   //minDeposit            : new BN(20).mul(new BN(10).pow(new BN(18))),
//   minDeposit            : new BN(40).mul(new BN(10).pow(new BN(18))),
//   withdrawDelayTime     : 60 * 60 * 72,
//   name                  : web3.utils.asciiToHex('Eos'),
//   symbol                : web3.utils.asciiToHex('EOS')
// };

// let tokenInfoNotReg = {
//   decimals              : 18,
//   tokenOrigAccount      : web3.utils.asciiToHex('Eos contract address1'),
//   token2WanRatio        : 10000,                  // 1:1
//   minDeposit            : new BN(20).mul(new BN(10).pow(new BN(18))),
//   withdrawDelayTime     : 60 * 60 * 72,
//   name                  : web3.utils.asciiToHex('Eos1'),
//   symbol                : web3.utils.asciiToHex('EOS1')
// };

// const v1            = new BN(20).mul(new BN(10).pow(new BN(tokenInfo.decimals)));
// const v2            = new BN(10).mul(new BN(10).pow(new BN(tokenInfo.decimals)));
// const v3            = new BN(5).mul(new BN(10).pow(new BN(tokenInfo.decimals)));
// const v4            = new BN(2).mul(new BN(10).pow(new BN(tokenInfo.decimals)));
// const v5            = new BN(1).mul(new BN(10).pow(new BN(tokenInfo.decimals)));
// const v100          = new BN(100).mul(new BN(10).pow(new BN(tokenInfo.decimals)));


// const appproveValue     = new BN(20).mul(new BN(10).pow(new BN(tokenInfo.decimals)));
// const valueZero         = 0;

// const srcDebtStoremanPK     = schnorr.getPKBySk(skInfo.srcSmg);
// const dstDebtStoremanPK     = schnorr.getPKBySk(skInfo.dstSmg);
// const srcDebtStoremanPK1    = schnorr.getPKBySk(skInfo.srcSmg1);


// const storemanPK1           = schnorr.getPKBySk(skInfo.smg1);
// const txFeeRatio1           = '20';

// const storemanPK2           = schnorr.getPKBySk(skInfo.smg2);
// const quota2                = '200';
// const txFeeRatio2           = '20';

// const R                     = schnorr.getR();
// const s                     = '0x0c595b48605562a1a6492540b875da4ff203946a9dd0e451cd33d06ef568626b';



// let htlcUserRedeemParams    = {
//   tokenOrigAccount: tokenInfo.tokenOrigAccount,
//   x: xInfo[1].x
// };

// let htlcUserLockParams      = {
//   xHash: xInfo[2].hash,
//   value: v2,
//   tokenOrigAccount: tokenInfo.tokenOrigAccount,
//   storemanGroupPK: storemanPK1,
// };

// let htlcSmgRedeemParams     = {
//   tokenOrigAccount: tokenInfo.tokenOrigAccount,
//   tokenManager: '',
//   r: R,
//   s: s,
//   x: xInfo[1].x,
//   skSmg: skInfo.smg1
// };

// let addSmgParams            = {
//   tokenOrigAccount: tokenInfo.tokenOrigAccount,
//   storemanGroupPK: storemanPK1,
//   quota: tokenInfo.minDeposit,
//   txFeeRatio: txFeeRatio1
// };

// let htlcDebtLockParams      = {
//   tokenOrigAccount: tokenInfo.tokenOrigAccount,
//   xHash: xInfo[6].hash,
//   value: v1,
//   srcStoremanPK: srcDebtStoremanPK,
//   dstStoremanPK: dstDebtStoremanPK,
//   r: R,
//   s: s,
//   skInfo.srcSmg: skInfo.srcSmg,
//   skInfo.dstSmg: skInfo.dstSmg,
// };

// let htlcDebtRedeemParams    = {
//   tokenOrigAccount: tokenInfo.tokenOrigAccount,
//   r: R,
//   s: s,
//   x: xInfo[6].x,
//   skSmg: skInfo.srcSmg,
// };

// let PrmTypeList             = {
//     //tokenOrigAccount    xHash   wanAddr   value
//     inSmgLock: ['bytes', 'bytes32', 'address', 'uint'],
//     // timeout receiver
//     smgWithdrawFee: ['uint','address'],
//     // x
//     outSmgRedeem: ['bytes32'],
//     // x
//     inDebtRedeem: ['bytes32'],
//     //tokenOrigAccount    xHash   srcStoremanPK value
//     inDebtLock: ['bytes', 'bytes32', 'bytes', 'uint']
// };

let crossDelegateNotInit;
let origTokenOwner;
const from = require('../truffle').networks.development.from;

const InvalidTokenPairID          = 100;
const htlcLockedTime              = 40; //unit: s
const quotaDepositRate            = 15000;

const ADDRESS_0                   = "0x0000000000000000000000000000000000000000";
const ADDRESS_TM                  = '0x0000000000000000000000000000000000000001';
const ADDRESS_SMGADMIN            = '0x0000000000000000000000000000000000000002';
const ADDRESS_CROSS_PROXY_IMPL    = '0x0000000000000000000000000000000000000003';

let defaultCurve = {
    curve1                    : 1,
    curve2                    : 2
};

let defaultChainID = {
    chain1                    : 10,
    chain2                    : 11
};

let coins = {
    coin1: {
        tokenPairID           : 0,
        origChainID           : defaultChainID.chain1,
        shadowChainID         : defaultChainID.chain2,
        origTokenAccount      : ADDRESS_0,
        shadowTokenAccount    : "", 
        decimals              : 18,
        name                  : 'WAN',
        symbol                : 'WAN',
        price                 : 23e-18
    },
    coin2: {
        tokenPairID           : 1,
        origChainID           : defaultChainID.chain1,
        shadowChainID         : defaultChainID.chain2,
        origTokenAccount      : ADDRESS_0,
        shadowTokenAccount    : "",
        decimals              : 18,
        name                  : 'ETH',
        symbol                : 'ETH',
        price                 : 243e-18
    }
}

let tokens = {
    token1: {
        tokenCreator          : null,
        tokenPairID           : 2,
        origChainID           : defaultChainID.chain1,
        shadowChainID         : defaultChainID.chain2,
        origTokenAccount      : "",
        shadowTokenAccount    : "",
        decimals              : 18,
        name                  : 'TST1',
        symbol                : 'TST1',
        price                 : 3e-18
    },
    token2: {
        tokenCreator          : null,
        tokenPairID           : 3,
        origChainID           : defaultChainID.chain2,
        shadowChainID         : defaultChainID.chain1,
        origTokenAccount      : "",
        shadowTokenAccount    : "",
        decimals              : 16,
        name                  : 'TST2',
        symbol                : 'TST2',
        price                 : 7e-18
    }
};

let crossApproach = {
    chain1: {
        instance              : null,
        delegate              : ADDRESS_0,
        origLockFee           : 10,
        origRevokeFee         : 11,
        shadowLockFee         : 12,
        shadowRevokeFee       : 13,
        parnters              : {
            tokenManager      : null,
            smgAdminProxy     : null,
            smgFeeProxy       : null,
            quota             : null,
            oracle            : null,
            sigVerifier       : null,
        },
    },
    chain2: {
        instance              : null,
        delegate              : ADDRESS_0,
        origLockFee           : 20,
        origRevokeFee         : 21,
        shadowLockFee         : 22,
        shadowRevokeFee       : 23,
        parnters              : {
            tokenManager      : null,
            smgAdminProxy     : null,
            smgFeeProxy       : null,
            quota             : null,
            oracle            : null,
            sigVerifier       : null,
        },
    },
};

let chains = {
    1: {
        ID                     : defaultChainID.chain1,
        coin                   : coins.coin1,
        token                  : tokens.token1,
        approach               : crossApproach.chain1
    },
    2: {
        ID                     : defaultChainID.chain2,
        coin                   : coins.coin2,
        token                  : tokens.token2,
        approach               : crossApproach.chain2
    }
}

let storemanGroupStatus = {
    none                      : 0,
    initial                   : 1,
    curveSeted                : 2,
    failed                    : 3,
    selected                  : 4,
    ready                     : 5,
    unregistered              : 6,
    dismissed                 : 7
};

let storemanGroups = {
    1: {
        ID                    : "0x01",
        account               : "", // accounts 1 or 2
        // deposit               : new BN(web3.utils.padRight(0x1, 50)),
        deposit               : "90000000000000000000000000000000000",
        status                : storemanGroupStatus.none,
        chain1                : defaultChainID.chain1,
        chain2                : defaultChainID.chain2,
        gpk1                  : schnorr.getPKBySk(skInfo.smg1[1]),
        gpk2                  : schnorr.getPKBySk(skInfo.smg1[2]),
        startTime             : 0,
        endTime               : Number.MAX_SAFE_INTEGER,
        R                     : schnorr.getR(),
        s                     : '0x0c595b48605562a1a6492540b875da4ff203946a9dd0e451cd33d06ef568626b'
    },
    2: {
        ID                    : "0x02",
        account               : "", // accounts 1 or 2
        // deposit               : new BN(web3.utils.padRight(0x2, 50)),
        deposit               : "99000000000000000000000000000000000",
        status                : storemanGroupStatus.none,
        chain1                : defaultChainID.chain1,
        chain2                : defaultChainID.chain2,
        gpk1                  : schnorr.getPKBySk(skInfo.smg2[1]),
        gpk2                  : schnorr.getPKBySk(skInfo.smg2[2]),
        startTime             : 0,
        endTime               : Number.MAX_SAFE_INTEGER,
        R                     : schnorr.getR(),
        s                     : '0x0c595b48605562a1a6492540b875da4ff203946a9dd0e451cd33d06ef568626b'
    },
};

let userMintLockParams       = {
    // xHash: xInfo[1].hash,
    xHash: '',
    smgID: storemanGroups[1].ID,
    tokenPairID: tokens.token1.tokenPairID,
    value: 10,
    origUserAccount: '', // accounts 3 or 4
    shadowUserAccount: '', // accounts 3 or 4
    lockFee: crossApproach.chain1.origLockFee + 1,
    revokeFee: crossApproach.chain1.origRevokeFee + 2
};

let smgMintLockParams       = {
    xHash: '',
    smgID: storemanGroups[1].ID,
    tokenPairID: tokens.token1.tokenPairID,
    value: userMintLockParams.value,
    origUserAccount: '', // accounts 3 or 4
    shadowUserAccount: '', // accounts 3 or 4
    R: '',
    s: ''
  };

let owner = require('../truffle.js').networks.development.from;

contract('Test HTLC', async (accounts) => {
    before("init...   -> success", async () => {
        try {
            await testInit();

            // set owner
            owner = from ? from : accounts[0];
            origTokenOwner = accounts[1];

            console.log("init 1", await getBalance(owner));

            // await web3.eth.sendTransaction({from: owner, to: wTokenAddr, value: web3.utils.toWei("0.5")})

            // storeman admin proxy
            let smgAdminProxy = await TestStoremanAdmin.new();
            console.log("init 2", await getBalance(owner));

            // signature verifier
            let bn128 = await Bn128SchnorrVerifier.deployed();
            let secp256K1 = await Secp256k1SchnorrVerifier.deployed();
            let sigVerifier = await SignatureVerifier.deployed();
            // register signature verifier contracts
            await sigVerifier.register(defaultCurve.curve1, secp256K1.address, {from: owner});
            console.log("init 3", await getBalance(owner));
            // await sigVerifier.register(defaultCurve.curve2, bn128.address, {from: owner});
            await sigVerifier.register(defaultCurve.curve2, secp256K1.address, {from: owner});
            console.log("init 4", await getBalance(owner));

            // quota1
            let quotaProxy = await QuotaProxy.deployed();
            let quotaDelegate = await QuotaDelegate.deployed();
            let quota1 = await QuotaDelegate.at(quotaProxy.address);
            console.log("init 5", await getBalance(owner));

            // quota2
            let quota2 = await QuotaDelegate.new();
            console.log("init 6", await getBalance(owner));

            // oracle
            let oracleProxy = await OracleProxy.deployed();
            let oracleDelegate = await OracleDelegate.deployed();
            let oracle = await OracleDelegate.at(oracleProxy.address);
            console.log("init 7", await getBalance(owner));

            // token manager proxy
            let tokenManagerProxy = await TokenManagerProxy.deployed();
            let tokenManagerDelegate = await TokenManagerDelegate.deployed();
            let tokenManager = await TokenManagerDelegate.at(tokenManagerProxy.address);
            console.log("init 8", await getBalance(owner));

            // cross approach
            let crossProxy = await CrossProxy.deployed();
            let crossDelegate = await CrossDelegate.deployed();
            crossApproach.chain1.instance = await CrossDelegate.at(crossProxy.address);
            console.log("init 9", await getBalance(owner));
            await crossApproach.chain1.instance.setLockedTime(htlcLockedTime) //second
            console.log("init 10", await getBalance(owner));
            await crossApproach.chain1.instance.setPartners(tokenManager.address, smgAdminProxy.address, smgAdminProxy.address, quota1.address, sigVerifier.address);
            console.log("init 11", await getBalance(owner));
            await crossApproach.chain1.instance.setFees(defaultChainID.chain1, defaultChainID.chain2, crossApproach.chain1.origLockFee, crossApproach.chain1.origRevokeFee);
            console.log("init 12", await getBalance(owner));
            await crossApproach.chain1.instance.setFees(defaultChainID.chain2, defaultChainID.chain1, crossApproach.chain1.shadowLockFee, crossApproach.chain1.shadowRevokeFee);
            console.log("init 13", await getBalance(owner));
            crossApproach.chain1.parnters.tokenManager = tokenManager;
            crossApproach.chain1.parnters.smgAdminProxy = smgAdminProxy;
            crossApproach.chain1.parnters.smgFeeProxy = smgAdminProxy.address;
            crossApproach.chain1.parnters.quota = quota1;
            crossApproach.chain1.parnters.oracle = oracle;
            crossApproach.chain1.parnters.sigVerifier = sigVerifier;
            crossApproach.chain1.delegate = crossDelegate;

            // storeman admin setup
            await smgAdminProxy.addChainInfo(defaultChainID.chain1, defaultChainID.chain2, defaultCurve.curve1, defaultCurve.curve2);
            console.log("init 14", await getBalance(owner));
            var totalChainPair = await smgAdminProxy.getChainPairIDCount.call();
            var chainPairID = Number(totalChainPair) - 1;
            // console.log("deposit", typeof(storemanGroups[1].deposit));
            // console.log("deposit", web3.utils.toWei(storemanGroups[1].deposit));
            // storeman group 1
            await smgAdminProxy.addStoremanGroup(storemanGroups[1].ID, storemanGroupStatus.ready,
                web3.utils.toWei(storemanGroups[1].deposit), chainPairID, storemanGroups[1].gpk1,
                storemanGroups[1].gpk2, storemanGroups[1].startTime, storemanGroups[1].endTime);
            storemanGroups[1].status = storemanGroupStatus.ready;
            console.log("init 15", await getBalance(owner));
            let regSmg1Info = await smgAdminProxy.getStoremanGroupConfig.call(storemanGroups[1].ID);
            assert.equal(storemanGroups[1].status, regSmg1Info[1]);
            assert.equal(web3.utils.toWei(storemanGroups[1].deposit), regSmg1Info[2]);
            assert.equal(storemanGroups[1].chain1, Number(regSmg1Info[3]));
            assert.equal(storemanGroups[1].chain2, Number(regSmg1Info[4]));
            assert.equal(defaultCurve.curve1, Number(regSmg1Info[5]));
            assert.equal(defaultCurve.curve2, Number(regSmg1Info[6]));
            assert.equal(storemanGroups[1].gpk1, regSmg1Info[7]);
            assert.equal(storemanGroups[1].gpk2, regSmg1Info[8]);
            assert.equal(storemanGroups[1].startTime, Number(regSmg1Info[9]));
            assert.equal(storemanGroups[1].endTime, Number(regSmg1Info[10]));
            storemanGroups[1].account = accounts[2];

            // storeman group 2
            await smgAdminProxy.addStoremanGroup(storemanGroups[2].ID, storemanGroupStatus.ready,
                web3.utils.toWei(storemanGroups[2].deposit), chainPairID, storemanGroups[2].gpk1,
                storemanGroups[2].gpk2, storemanGroups[2].startTime, storemanGroups[2].endTime);
            console.log("init 16", await getBalance(owner));
            storemanGroups[2].status = storemanGroupStatus.ready;
            let regSmg2Info = await smgAdminProxy.getStoremanGroupConfig.call(storemanGroups[2].ID);
            assert.equal(storemanGroups[2].status, regSmg2Info[1]);
            assert.equal(web3.utils.toWei(storemanGroups[2].deposit), regSmg2Info[2]);
            assert.equal(storemanGroups[2].chain1, Number(regSmg2Info[3]));
            assert.equal(storemanGroups[2].chain2, Number(regSmg2Info[4]));
            assert.equal(defaultCurve.curve1, Number(regSmg2Info[5]));
            assert.equal(defaultCurve.curve2, Number(regSmg2Info[6]));
            // console.log("curve1", regSmg2Info[5], "curve2", regSmg2Info[6]);
            assert.equal(storemanGroups[2].gpk1, regSmg2Info[7]);
            assert.equal(storemanGroups[2].gpk2, regSmg2Info[8]);
            assert.equal(storemanGroups[2].startTime, Number(regSmg2Info[9]));
            assert.equal(storemanGroups[2].endTime, Number(regSmg2Info[10]));
            storemanGroups[2].account = accounts[3];

            crossDelegateNotInit = await CrossDelegate.new();
            console.log("init 17", await getBalance(owner));

            crossApproach.chain2.delegate = await CrossDelegate.new({from: owner});
            console.log("init 18", await getBalance(owner));
            let chain2CrossProxy = await CrossProxy.new({from: owner});
            console.log("init 19", await getBalance(owner));
            await chain2CrossProxy.upgradeTo(crossApproach.chain2.delegate.address, {from: owner});
            console.log("init 20", await getBalance(owner));
            crossApproach.chain2.instance = await CrossDelegate.at(chain2CrossProxy.address);
            console.log("init 21", await getBalance(owner));
            await crossApproach.chain2.instance.setLockedTime(htlcLockedTime) //second
            console.log("init 22", await getBalance(owner));
            await crossApproach.chain2.instance.setPartners(tokenManager.address, oracle.address, ADDRESS_0, quota2.address, sigVerifier.address);
            console.log("init 23", await getBalance(owner));
            await crossApproach.chain2.instance.setFees(defaultChainID.chain2, defaultChainID.chain1, crossApproach.chain2.origLockFee, crossApproach.chain2.origRevokeFee);
            console.log("init 24", await getBalance(owner));
            await crossApproach.chain2.instance.setFees(defaultChainID.chain1, defaultChainID.chain2, crossApproach.chain2.shadowLockFee, crossApproach.chain2.shadowRevokeFee);
            console.log("init 25", await getBalance(owner));
            crossApproach.chain2.parnters.tokenManager = tokenManager;
            crossApproach.chain2.parnters.smgAdminProxy = oracle;
            crossApproach.chain2.parnters.smgFeeProxy = ADDRESS_0;
            crossApproach.chain2.parnters.quota = quota2;
            crossApproach.chain2.parnters.oracle = oracle;
            crossApproach.chain2.parnters.sigVerifier = sigVerifier;

            // original token creator contract
            tokens.token1.tokenCreator = await TestOrigTokenCreator.new();
            console.log("init 26", await getBalance(owner));
            await tokens.token1.tokenCreator.setAdmin(crossApproach.chain1.instance.address, {from: owner})
            console.log("init 27", await getBalance(owner));
            await tokens.token1.tokenCreator.createToken(tokens.token1.name, tokens.token1.symbol, tokens.token1.decimals);
            console.log("init 28", await getBalance(owner));
            tokens.token1.origTokenAccount = await tokens.token1.tokenCreator.getTokenAddr.call(tokens.token1.name, tokens.token1.symbol);
            // let origTokenContract = new web3.eth.Contract(tokenRC20Abi, tokens.token1.origTokenAccount);

            // /* change original token contract owner request */
            // let changeOwnerTx = await tokens.token1.tokenCreator.changeOwner(tokens.token1.name, tokens.token1.symbol, origTokenOwner, {from: owner});
            // /* accept change original token contract owner request */
            // await origTokenContract.methods.acceptOwnership().send({from: origTokenOwner});
            // var mintTokenTx = await tokens.token1.tokenCreator.mintToken(tokens.token1.name, tokens.token1.symbol, origUser, web3.utils.toWei(origUserBalance.toString()))

            tokens.token2.tokenCreator = await TestOrigTokenCreator.new();
            console.log("init 29", await getBalance(owner));
            await tokens.token2.tokenCreator.setAdmin(crossApproach.chain2.instance.address, {from: owner})
            console.log("init 30", await getBalance(owner));
            await tokens.token2.tokenCreator.createToken(tokens.token2.name, tokens.token2.symbol, tokens.token2.decimals);
            console.log("init 31", await getBalance(owner));
            tokens.token2.origTokenAccount = await tokens.token2.tokenCreator.getTokenAddr.call(tokens.token2.name, tokens.token1.symbol);
            // let origTokenContract = new web3.eth.Contract(tokenRC20Abi, tokens.token2.origTokenAccount);

            // /* change original token contract owner request */
            // let changeOwnerTx = await tokens.token2.tokenCreator.changeOwner(tokens.token2.name, tokenManager.token2.symbol, origTokenOwner, {from: owner});
            // /* accept change original token contract owner request */
            // await origTokenContract.methods.acceptOwnership().send({from: origTokenOwner});
            // var mintTokenTx = await tokens.token2.tokenCreator.mintToken(tokens.token2.name, tokenManager.token2.symbol, origUser, web3.utils.toWei(origUserBalance.toString()))

            // token manager admin
            // token1
            let shadowToken1Receipt = await tokenManager.addToken(tokens.token1.name, tokens.token1.symbol, tokens.token1.decimals);
            console.log("init 32", await getBalance(owner));
            // console.log(shadowToken1Receipt.logs);
            let shadowToken1Logger = assert.getWeb3Log(shadowToken1Receipt, {
                event: 'AddToken'
            });
            tokens.token1.shadowTokenAccount = shadowToken1Logger.args.tokenAddress;
            assert.equal(tokens.token1.name, shadowToken1Logger.args.name);
            assert.equal(tokens.token1.symbol, shadowToken1Logger.args.symbol);
            assert.equal(tokens.token1.decimals, Number(shadowToken1Logger.args.decimals));
            // console.log("check OK");

            let token1PairReceipt = await tokenManager.addTokenPair(tokens.token1.tokenPairID,
                [tokens.token1.origTokenAccount, tokens.token1.name, tokens.token1.symbol, tokens.token1.decimals, tokens.token1.origChainID],
                tokens.token1.origChainID, tokens.token1.origTokenAccount, tokens.token1.shadowChainID, tokens.token1.shadowTokenAccount);
            // console.log("token1PairReceipt", token1PairReceipt.logs);
            assert.checkWeb3Event(token1PairReceipt, {
                event: 'AddTokenPair',
                args: {
                    id: tokens.token1.tokenPairID,
                    fromChainID: tokens.token1.origChainID,
                    fromAccount: tokens.token1.origTokenAccount.toLowerCase(),//web3.utils.hexToBytes(tokens.token1.origTokenAccount),// web3.utils.padRight(tokens.token1.origTokenAccount, 64).toLowerCase(),
                    toChainID: tokens.token1.shadowChainID,
                    tokenAddress: tokens.token1.shadowTokenAccount
                }
            });
            console.log("init 33", await getBalance(owner));

            // token2
            let shadowToken2Receipt = await tokenManager.addToken(tokens.token2.name, tokens.token2.symbol, tokens.token2.decimals);
            console.log("init 34", await getBalance(owner));
            let shadowToken2Logger = assert.getWeb3Log(shadowToken2Receipt, {
                event: 'AddToken'
            });
            tokens.token2.shadowTokenAccount = shadowToken2Logger.args.tokenAddress;
            assert.equal(tokens.token2.name, shadowToken2Logger.args.name);
            assert.equal(tokens.token2.symbol, shadowToken2Logger.args.symbol);
            assert.equal(tokens.token2.decimals, shadowToken2Logger.args.decimals);
            // console.log("check OK");

            let token2PairReceipt = await tokenManager.addTokenPair(tokens.token2.tokenPairID,
                [tokens.token2.origTokenAccount, tokens.token2.name, tokens.token2.symbol, tokens.token2.decimals, tokens.token2.origChainID],
                tokens.token2.origChainID, tokens.token2.origTokenAccount, tokens.token2.shadowChainID, tokens.token2.shadowTokenAccount);
            console.log("init 35", await getBalance(owner));
            assert.checkWeb3Event(token2PairReceipt, {
                event: 'AddTokenPair',
                args: {
                    id: tokens.token2.tokenPairID,
                    fromChainID: tokens.token2.origChainID,
                    fromAccount: tokens.token2.origTokenAccount.toLowerCase(),//web3.utils.hexToBytes(tokens.token2.origTokenAccount),//web3.utils.padRight(tokens.token2.origTokenAccount, 64).toLowerCase(),
                    toChainID: tokens.token2.shadowChainID,
                    tokenAddress: tokens.token2.shadowTokenAccount
                }
            });

            // coin1
            let shadowCoin1Receipt = await tokenManager.addToken(coins.coin1.name, coins.coin1.symbol, coins.coin1.decimals);
            console.log("init 36", await getBalance(owner));
            // console.log(shadowCoin1Receipt.logs);
            let shadowCoin1Logger = assert.getWeb3Log(shadowCoin1Receipt, {
                event: 'AddToken'
            });
            coins.coin1.shadowTokenAccount = shadowCoin1Logger.args.tokenAddress;
            assert.equal(coins.coin1.name, shadowCoin1Logger.args.name);
            assert.equal(coins.coin1.symbol, shadowCoin1Logger.args.symbol);
            assert.equal(coins.coin1.decimals, Number(shadowCoin1Logger.args.decimals));

            let coin1PairReceipt = await tokenManager.addTokenPair(coins.coin1.tokenPairID,
                [coins.coin1.origTokenAccount, coins.coin1.name, coins.coin1.symbol, coins.coin1.decimals, coins.coin1.origChainID],
                coins.coin1.origChainID, coins.coin1.origTokenAccount, coins.coin1.shadowChainID, coins.coin1.shadowTokenAccount);
            assert.checkWeb3Event(coin1PairReceipt, {
                event: 'AddTokenPair',
                args: {
                    id: coins.coin1.tokenPairID,
                    fromChainID: coins.coin1.origChainID,
                    fromAccount: coins.coin1.origTokenAccount.toLowerCase(),//web3.utils.hexToBytes(coins.coin1.origTokenAccount),//web3.utils.padRight(coins.coin1.origTokenAccount, 64).toLowerCase(),
                    toChainID: coins.coin1.shadowChainID,
                    tokenAddress: coins.coin1.shadowTokenAccount
                }
            });
            console.log("init 37", await getBalance(owner));

            // coin2
            let shadowCoin2Receipt = await tokenManager.addToken(coins.coin2.name, coins.coin2.symbol, coins.coin2.decimals);
            console.log("init 38", await getBalance(owner));
            let shadowCoin2Logger = assert.getWeb3Log(shadowCoin2Receipt, {
                event: 'AddToken'
            });
            coins.coin2.shadowTokenAccount = shadowCoin2Logger.args.tokenAddress;
            assert.equal(coins.coin2.name, shadowCoin2Logger.args.name);
            assert.equal(coins.coin2.symbol, shadowCoin2Logger.args.symbol);
            assert.equal(coins.coin2.decimals, shadowCoin2Logger.args.decimals);
            // console.log("check OK");

            let coin2PairReceipt = await tokenManager.addTokenPair(coins.coin2.tokenPairID,
                [coins.coin2.origTokenAccount, coins.coin2.name, coins.coin2.symbol, coins.coin2.decimals, coins.coin2.origChainID],
                coins.coin2.origChainID, coins.coin2.origTokenAccount, coins.coin2.shadowChainID, coins.coin2.shadowTokenAccount);
            console.log("init 39", await getBalance(owner));
            assert.checkWeb3Event(coin2PairReceipt, {
                event: 'AddTokenPair',
                args: {
                    id: coins.coin2.tokenPairID,
                    fromChainID: coins.coin2.origChainID,
                    fromAccount: coins.coin2.origTokenAccount.toLowerCase(),//web3.utils.hexToBytes(coins.coin2.origTokenAccount),//web3.utils.padRight(coins.coin2.origTokenAccount, 64).toLowerCase(),
                    toChainID: coins.coin2.shadowChainID,
                    tokenAddress: coins.coin2.shadowTokenAccount
                }
            });

            // token manager admin
            await tokenManager.addAdmin(crossApproach.chain1.instance.address, {from: owner});
            console.log("init 40", await getBalance(owner));

            await tokenManager.addAdmin(crossApproach.chain2.instance.address, {from: owner});
            console.log("init 41", await getBalance(owner));

            // oracle config
            let smg1ConfigReceipt = await oracle.setStoremanGroupConfig(storemanGroups[1].ID, storemanGroups[1].status,
                web3.utils.toWei(storemanGroups[1].deposit), [storemanGroups[1].chain1, storemanGroups[1].chain1],
                [web3.utils.padRight(web3.utils.toHex(defaultCurve.curve2), 64),
                web3.utils.padRight(web3.utils.toHex(defaultCurve.curve1), 64)],
                storemanGroups[1].gpk2, storemanGroups[1].gpk1,
                storemanGroups[1].startTime, storemanGroups[1].endTime, {from: owner});
            // console.log("smg1ConfigReceipt", smg1ConfigReceipt.logs);
            console.log("init 42", await getBalance(owner));

            let smg2ConfigReceipt = await oracle.setStoremanGroupConfig(storemanGroups[2].ID, storemanGroups[2].status,
                web3.utils.toWei(storemanGroups[2].deposit), [storemanGroups[2].chain2, storemanGroups[2].chain1],
                [web3.utils.padRight(web3.utils.toHex(defaultCurve.curve2), 64),
                web3.utils.padRight(web3.utils.toHex(defaultCurve.curve1), 64)],
                storemanGroups[2].gpk2, storemanGroups[2].gpk1,
                storemanGroups[2].startTime, storemanGroups[2].endTime, {from: owner});
            // console.log("smg2ConfigReceipt", smg2ConfigReceipt.logs);
            console.log("init 43", await getBalance(owner));
            let smg1DepositReceipt = await oracle.updateDeposit(storemanGroups[1].ID, web3.utils.toWei(storemanGroups[1].deposit), {from: owner});
            // assert.checkWeb3Event(smg1DepositReceipt, {
            //     event: 'UpdateDeposit',
            //     args: {
            //         smgID: web3.utils.padRight(storemanGroups[1].ID, 32),
            //         amount:web3.utils.toWei(storemanGroups[1].deposit)
            //     }
            // });
            // console.log("smg1DepositReceipt", smg1DepositReceipt.logs);
            console.log("init 44", await getBalance(owner));
            let smg2DepositReceipt = await oracle.updateDeposit(storemanGroups[2].ID, web3.utils.toWei(storemanGroups[2].deposit), {from: owner});
            // assert.checkWeb3Event(smg2DepositReceipt, {
            //     event: 'UpdateDeposit',
            //     args: {
            //         smgID: web3.utils.padRight(storemanGroups[2].ID, 32),
            //         amount:web3.utils.toWei(storemanGroups[2].deposit)
            //     }
            // });
            // console.log("smg2DepositReceipt", smg2DepositReceipt.logs);
            console.log("init 45", await getBalance(owner));
            let tokenSymbols = [
                web3.utils.hexToBytes(web3.utils.asciiToHex(tokens.token1.symbol)),
                web3.utils.hexToBytes(web3.utils.asciiToHex(tokens.token2.symbol)),
                web3.utils.hexToBytes(web3.utils.asciiToHex(coins.coin1.symbol)),
                web3.utils.hexToBytes(web3.utils.asciiToHex(coins.coin2.symbol)),
            ];
            let tokenPrices = [
                web3.utils.toWei(toNonExponential(tokens.token1.price)),
                web3.utils.toWei(toNonExponential(tokens.token2.price)),
                web3.utils.toWei(toNonExponential(coins.coin1.price)),
                web3.utils.toWei(toNonExponential(coins.coin2.price)),
            ];
            let priceLogger = await oracle.updatePrice(tokenSymbols, tokenPrices);
            console.log("init 46", await getBalance(owner));
            let oraclePrices = await oracle.getValues(tokenSymbols);
            assert.equal(oraclePrices[0].eq(new BN(tokenPrices[0])), true);
            assert.equal(oraclePrices[1].eq(new BN(tokenPrices[1])), true);
            assert.equal(oraclePrices[2].eq(new BN(tokenPrices[2])), true);
            assert.equal(oraclePrices[3].eq(new BN(tokenPrices[3])), true);

            // quota config
            let quota1ConfigReceipt = await quota1.config(
                oracle.address,
                crossApproach.chain1.instance.address,
                crossApproach.chain1.instance.address,
                smgAdminProxy.address,
                tokenManager.address,
                quotaDepositRate,
                web3.utils.hexToBytes(web3.utils.asciiToHex(coins.coin1.symbol)),
                {from: owner}
            );
            console.log("init 47", await getBalance(owner));

            let quota2ConfigReceipt = await quota2.config(
                oracle.address,
                crossApproach.chain2.instance.address,
                crossApproach.chain2.instance.address,
                oracle.address,
                tokenManager.address,
                quotaDepositRate,
                web3.utils.hexToBytes(web3.utils.asciiToHex(coins.coin2.symbol)),
                {from: owner}
            );
            console.log("init 48", await getBalance(owner));

        } catch (err) {
            // console.log(err);
            assert.fail(err);
        }
    });

    // it('init...   -> getStoremanFee success', async () => {
    //     try {
    //         let smgFee = await crossApproach.chain1.instance.getStoremanFee(storemanGroups[1].ID);
    //         assert.equal(new BN(smgFee).eq(new BN(0)), true);
    //         smgFee = await crossApproach.chain2.instance.getStoremanFee(storemanGroups[2].ID);
    //         assert.equal(new BN(smgFee).eq(new BN(0)), true);
    //     } catch (err) {
    //         assert.fail(err.toString());
    //     }
    // });

    // it('Others getPartners  ==> The config value', async () => {
    //     try {
    //         let ret = await crossApproach.chain1.instance.getPartners();
    //         assert.equal(crossApproach.chain1.parnters.tokenManager.address, ret[0]);
    //         assert.equal(crossApproach.chain1.parnters.smgAdminProxy.address, ret[1]);
    //         assert.equal(crossApproach.chain1.parnters.smgFeeProxy, ret[2]);
    //         assert.equal(crossApproach.chain1.parnters.quota.address, ret[3]);
    //         assert.equal(crossApproach.chain1.parnters.sigVerifier.address, ret[4]);

    //         ret = await crossApproach.chain2.instance.getPartners();
    //         assert.equal(crossApproach.chain2.parnters.tokenManager.address, ret[0]);
    //         assert.equal(crossApproach.chain2.parnters.smgAdminProxy.address, ret[1]);
    //         assert.equal(ADDRESS_0, ret[2]);
    //         assert.equal(crossApproach.chain2.parnters.quota.address, ret[3]);
    //         assert.equal(crossApproach.chain2.parnters.sigVerifier.address, ret[4]);
    //     } catch (err) {
    //         assert.fail(err.toString());
    //     }
    // });

    // it('Others setEconomics  ==> Parameter is invalid', async () => {
    //     try {
    //         await crossApproach.chain1.instance.setPartners(ADDRESS_0, ADDRESS_0, crossApproach.chain1.parnters.smgFeeProxy, ADDRESS_0, ADDRESS_0);
    //     } catch (err) {
    //         assert.include(err.toString(), "Parameter is invalid");
    //     }
    // });

    // it('Others getFees  ==> The config value', async () => {
    //     try {
    //         let ret = await crossApproach.chain1.instance.getFees(defaultChainID.chain1, defaultChainID.chain2);
    //         assert.equal(crossApproach.chain1.origLockFee, ret[0]);
    //         assert.equal(crossApproach.chain1.origRevokeFee, ret[1]);

    //         ret = await crossApproach.chain1.instance.getFees(defaultChainID.chain2, defaultChainID.chain1);
    //         assert.equal(crossApproach.chain1.shadowLockFee, ret[0]);
    //         assert.equal(crossApproach.chain1.shadowRevokeFee, ret[1]);

    //         ret = await crossApproach.chain2.instance.getFees(defaultChainID.chain2, defaultChainID.chain1);
    //         assert.equal(crossApproach.chain2.origLockFee, ret[0]);
    //         assert.equal(crossApproach.chain2.origRevokeFee, ret[1]);

    //         ret = await crossApproach.chain2.instance.getFees(defaultChainID.chain1, defaultChainID.chain2);
    //         assert.equal(crossApproach.chain2.shadowLockFee, ret[0]);
    //         assert.equal(crossApproach.chain2.shadowRevokeFee, ret[1]);

    //     } catch (err) {
    //         assert.fail(err.toString());
    //     }
    // });

    // it('Others lockedTime  ==> The config value', async () => {
    //     try {
    //         let ret = await crossApproach.chain1.instance._lockedTime();
    //         assert.equal(htlcLockedTime, ret);
    //     } catch (err) {
    //         assert.fail(err.toString());
    //     }
    // });

    // it('Proxy   -> get the implementation address', async () => {
    //     try {
    //         let crossProxy = await CrossProxy.at(crossApproach.chain1.instance.address);
    //         let address = await crossProxy.implementation();
    //         assert.equal(address, crossApproach.chain1.delegate.address);
    //     } catch (err) {
    //         assert.fail(err.toString());
    //     }
    // });

    // it('Proxy   -> upgradeTo', async () => {
    //     try {
    //         let crossProxy = await CrossProxy.at(crossApproach.chain1.instance.address);
    //         await crossProxy.upgradeTo(ADDRESS_CROSS_PROXY_IMPL);

    //         let address = await crossProxy.implementation();
    //         assert.equal(address, ADDRESS_CROSS_PROXY_IMPL);
    //     } catch (err) {
    //         assert.fail(err.toString());
    //     }
    // });

    // it('Proxy   -> upgradeTo with the same implementation address', async () => {
    //     try {
    //         let crossProxy = await CrossProxy.at(crossApproach.chain1.instance.address);
    //         await crossProxy.upgradeTo(ADDRESS_CROSS_PROXY_IMPL);

    //         let address = await crossProxy.implementation();
    //         assert.equal(address, ADDRESS_CROSS_PROXY_IMPL);
    //     } catch (err) {
    //         assert.include(err.toString(), "Cannot upgrade to the same implementation");
    //     }
    // });

    // it('Proxy   -> upgradeTo with 0x address', async () => {
    //     try {
    //         let crossProxy = await CrossProxy.at(crossApproach.chain1.instance.address);
    //         await crossProxy.upgradeTo(ADDRESS_0);

    //         let address = await crossProxy.implementation();
    //         assert.equal(address, ADDRESS_0);
    //     } catch (err) {
    //         assert.include(err.toString(), "Cannot upgrade to invalid address");
    //     }
    // });

    // it('Proxy   -> restore', async () => {
    //     try {
    //         let crossProxy = await CrossProxy.at(crossApproach.chain1.instance.address);
    //         let ret = await crossProxy.upgradeTo(crossApproach.chain1.delegate.address);
    //         let address = await crossProxy.implementation();
    //         assert.equal(address, crossApproach.chain1.delegate.address);

    //         assert.checkWeb3Event(ret, {
    //             event: 'Upgraded',
    //             args: {
    //                 implementation:address
    //             }
    //         });
    //     } catch (err) {
    //         assert.fail(err.toString());
    //     }
    // });

    // it('Token1 -> userMintLock  ==> Halted', async () => {
    //     let crossProxy;
    //     try {
    //         crossProxy = await CrossProxy.at(crossApproach.chain1.instance.address);
    //         await crossProxy.setHalt(true, {from: owner});
    //         // accounts[1] is the chain1 original address of the user.
    //         let userMintLockParamsTemp = Object.assign({}, userMintLockParams);
    //         userMintLockParamsTemp.origUserAccount = accounts[3];
    //         userMintLockParamsTemp.shadowUserAccount = accounts[4];
    //         userMintLockParamsTemp.xHash = xInfo[1].hash;
    //         await crossApproach.chain1.instance.userMintLock(
    //             userMintLockParamsTemp.xHash,
    //             userMintLockParamsTemp.smgID,
    //             userMintLockParamsTemp.tokenPairID,
    //             web3.utils.toWei(userMintLockParamsTemp.value.toString()),
    //             userMintLockParamsTemp.shadowUserAccount, {from: userMintLockParamsTemp.origUserAccount});
    //     } catch (err) {
    //         assert.include(err.toString(), "Smart contract is halted");
    //     } finally {
    //         await crossProxy.setHalt(false, {from: owner});
    //     }
    // });

    // it("Token1 -> userMintLock  ==> Invalid parnters", async () => {
    //     try {
    //         // accounts[1] is the chain1 original address of the user.
    //         let userMintLockParamsTemp = Object.assign({}, userMintLosetValueckParams);
    //         userMintLockParamsTemp.origUserAccount = accounts[3];
    //         userMintLockParamsTemp.shadowUserAccount = accounts[4];
    //         userMintLockParamsTemp.xHash = xInfo[1].hash;
    //         await crossDelegateNotInit.userMintLock(
    //             userMintLockParamsTemp.xHash,
    //             userMintLockParamsTemp.smgID,
    //             userMintLockParamsTemp.tokenPairID,
    //             web3.utils.toWei(userMintLockParamsTemp.value.toString()),
    //             userMintLockParamsTemp.shadowUserAccount, {from: userMintLockParamsTemp.origUserAccount});
    //     } catch (err) {
    //         //assert.fail(err);
    //         assert.include(err.toString(), "Invalid parnters");
    //     }
    // });

    // it("Token1 -> userMintLock  ==> Token does not exist", async () => {
    //     try {
    //         // accounts[1] is the chain1 original address of the user.
    //         let userMintLockParamsTemp = Object.assign({}, userMintLockParams);
    //         userMintLockParamsTemp.origUserAccount = accounts[3];
    //         userMintLockParamsTemp.shadowUserAccount = accounts[4];
    //         userMintLockParamsTemp.xHash = xInfo[1].hash;

    //         let value = web3.utils.toWei(userMintLockParamsTemp.value.toString());
    //         // user mint lock
    //         await crossApproach.chain1.instance.userMintLock(
    //             userMintLockParamsTemp.xHash,
    //             userMintLockParamsTemp.smgID,
    //             InvalidTokenPairID,
    //             value,
    //             userMintLockParamsTemp.shadowUserAccount,
    //             {from: userMintLockParamsTemp.origUserAccount, value: crossApproach.chain1.origLockFee});
    //     } catch (err) {
    //         assert.include(err.toString(), "Token does not exist");
    //     }
    // });

    // it("Token1 -> userMintLock  ==> Value is null", async () => {
    //     try {
    //         // accounts[1] is the chain1 original address of the user.
    //         let userMintLockParamsTemp = Object.assign({}, userMintLockParams);
    //         userMintLockParamsTemp.origUserAccount = accounts[3];
    //         userMintLockParamsTemp.shadowUserAccount = accounts[4];
    //         userMintLockParamsTemp.xHash = xInfo[1].hash;

    //         let value = web3.utils.toWei("0");
    //         // user mint lock
    //         await crossApproach.chain1.instance.userMintLock(
    //             userMintLockParamsTemp.xHash,
    //             userMintLockParamsTemp.smgID,
    //             userMintLockParamsTemp.tokenPairID,
    //             value,
    //             userMintLockParamsTemp.shadowUserAccount,
    //             {from: userMintLockParamsTemp.origUserAccount, value: crossApproach.chain1.origLockFee});
    //     } catch (err) {
    //         assert.include(err.toString(), "Value is null");
    //     }
    // });

    // it('Token1 -> smgMintLock  ==> Halted', async () => {
    //     let crossProxy;
    //     try {
    //         crossProxy = await CrossProxy.at(crossApproach.chain2.instance.address);
    //         await crossProxy.setHalt(true, {from: owner});
    //         // accounts[3] is the chain1 original address of the user.
    //         // accounts[4] is the chain2 shadow address of the user.
    //         let smgMintLockParamsTemp = Object.assign({}, smgMintLockParams);
    //         smgMintLockParamsTemp.origUserAccount = accounts[3];
    //         smgMintLockParamsTemp.shadowUserAccount = accounts[4];
    //         smgMintLockParamsTemp.xHash = xInfo[1].hash;
    //         smgMintLockParamsTemp.R = storemanGroups[1].R;
    //         smgMintLockParamsTemp.s = storemanGroups[1].s;

    //         let value = web3.utils.toWei(smgMintLockParamsTemp.value.toString());

    //         // storeman mint lock
    //         let smgMintLockReceipt = await crossApproach.chain2.instance.smgMintLock(
    //             smgMintLockParamsTemp.xHash,
    //             smgMintLockParamsTemp.smgID,
    //             smgMintLockParamsTemp.tokenPairID,
    //             value,
    //             smgMintLockParamsTemp.shadowUserAccount,
    //             smgMintLockParamsTemp.R,
    //             smgMintLockParamsTemp.s,
    //             {from: storemanGroups[1].account});
    //         // console.log("smgMintLock receipt", smgMintLockReceipt.logs);
    //     } catch (err) {
    //         assert.include(err.toString(), "Smart contract is halted");
    //     } finally {
    //         await crossProxy.setHalt(false, {from: owner});
    //     }
    // });

    it('Token1 -> userMintLock  ==>success', async () => {
        try {
            // accounts[1] is the chain1 original address of the user.
            let userMintLockParamsTemp = Object.assign({}, userMintLockParams);
            userMintLockParamsTemp.origUserAccount = accounts[3];
            userMintLockParamsTemp.shadowUserAccount = accounts[4];
            userMintLockParamsTemp.xHash = xInfo[1].hash;

            let mintOracleValue = await crossApproach.chain1.parnters.oracle.getDeposit(userMintLockParamsTemp.smgID);
            console.log("mintOracleValue", mintOracleValue);

            let mintQuotaValue = await crossApproach.chain1.parnters.quota.getMintQuota(userMintLockParamsTemp.tokenPairID, userMintLockParamsTemp.smgID);
            console.log("mintQuotaValue", mintQuotaValue);

            let value = web3.utils.toWei(userMintLockParamsTemp.value.toString());
            await tokens.token1.tokenCreator.mintToken(tokens.token1.name, tokens.token1.symbol,
                userMintLockParamsTemp.origUserAccount, value);
            // get token instance
            let tokenInstance = await getRC20TokenInstance(tokens.token1.origTokenAccount);
            let balance = await tokenInstance.balanceOf(userMintLockParamsTemp.origUserAccount);
            assert.equal(value, balance.toString());

            // approve value
            await tokenInstance.approve(crossApproach.chain1.instance.address, 0, {from: userMintLockParamsTemp.origUserAccount});
            await tokenInstance.approve(crossApproach.chain1.instance.address, value, {from: userMintLockParamsTemp.origUserAccount});
            let allowance = await tokenInstance.allowance(userMintLockParamsTemp.origUserAccount, crossApproach.chain1.instance.address);
            assert.equal(value, allowance.toString());

            // console.log("before origUserAccount", await web3.eth.getBalance(userMintLockParamsTemp.origUserAccount));
            // console.log("before crossApproach", await web3.eth.getBalance(crossApproach.chain1.instance.address));
            // user mint lock
            let userMintLockReceipt = await crossApproach.chain1.instance.userMintLock(
                userMintLockParamsTemp.xHash,
                userMintLockParamsTemp.smgID,
                userMintLockParamsTemp.tokenPairID,
                value,
                userMintLockParamsTemp.shadowUserAccount,
                {from: userMintLockParamsTemp.origUserAccount, value: crossApproach.chain1.origLockFee});
            // console.log("userMintLock receipt", userMintLockReceipt.logs);
            // console.log("after origUserAccount", await web3.eth.getBalance(userMintLockParamsTemp.origUserAccount));
            // console.log("after crossApproach", await web3.eth.getBalance(crossApproach.chain1.instance.address));
        } catch (err) {
            assert.fail(err);
        }
    });

    // it('Token1 -> smgMintLock  ==>success', async () => {
    //     try {
    //         // accounts[1] is the chain1 original address of the user.
    //         let smgMintLockParamsTemp = Object.assign({}, smgMintLockParams);
    //         smgMintLockParamsTemp.origUserAccount = accounts[3];
    //         smgMintLockParamsTemp.shadowUserAccount = accounts[4];
    //         smgMintLockParamsTemp.xHash = xInfo[1].hash;
    //         smgMintLockParamsTemp.R = storemanGroups[1].R;
    //         smgMintLockParamsTemp.s = storemanGroups[1].s;

    //         let value = web3.utils.toWei(smgMintLockParamsTemp.value.toString());

    //         // user mint lock
    //         let smgMintLockReceipt = await crossApproach.chain2.instance.smgMintLock(
    //             smgMintLockParamsTemp.xHash,
    //             smgMintLockParamsTemp.smgID,
    //             smgMintLockParamsTemp.tokenPairID,
    //             value,
    //             smgMintLockParamsTemp.shadowUserAccount,
    //             smgMintLockParamsTemp.R,
    //             smgMintLockParamsTemp.s,
    //             {from: storemanGroups[1].account});
    //         // console.log("smgMintLock receipt", smgMintLockReceipt.logs);
    //     } catch (err) {
    //         assert.fail(err);
    //     }
    // });

    // it('Token1 -> userMintRevoke  ==> should wait 2*lockedTime, not wait', async () => {
    //     try {
    //         let origUserAccount = accounts[3];;
    //         await crossApproach.chain2.instance.userMintRevoke(xInfo[1].hash, {from: origUserAccount, value: crossApproach.chain1.origRevokeFee});
    //     } catch (err) {
    //         assert.include(err.toString(), "Revoke is not permitted");
    //     }
    // });

    // it('Token1 -> userMintRedeem  ==>success', async () => {
    //     try {
    //         let shadowUserAccount = accounts[4];
    //         await crossApproach.chain2.instance.userMintRedeem(xInfo[1].x, {from: shadowUserAccount});
    //     } catch (err) {
    //         assert.fail(err);
    //     }
    // });

    // it('Token1 -> userMintRedeem ==> redeem twice, Status is not locked', async () => {
    //     try {
    //         let shadowUserAccount = accounts[4];
    //         await crossApproach.chain2.instance.userMintRedeem(xInfo[1].x, {from: shadowUserAccount});
    //     } catch (err) {
    //         assert.include(err.toString(), "Status is not locked");
    //     }
    // });

    // it('Token1 -> smgMintRedeem ==> Smart contract is halted', async () => {
    //     crossProxy = await CrossProxy.at(crossApproach.chain1.instance.address);
    //     await crossProxy.setHalt(true, {from: owner});
    //     try {
    //         await crossApproach.chain1.instance.smgMintRedeem(xInfo[1].x);
    //     } catch (err) {
    //         assert.include(err.toString(), "Smart contract is halted");
    //     } finally {
    //         await crossProxy.setHalt(false, {from: owner});
    //     }
    // });

    // it('Token1 -> smgMintRedeem  ==>success', async () => {
    //     try {
    //         await crossApproach.chain1.instance.smgMintRedeem(xInfo[1].x, {from: storemanGroups[1].account});
    //     } catch (err) {
    //         assert.fail(err);
    //     }
    // });

    // it('Token1 -> smgMintRedeem ==> redeem twice, Status is not locked', async () => {
    //     try {
    //         await crossApproach.chain1.instance.smgMintRedeem(xInfo[1].x, {from: storemanGroups[1].account});
    //     } catch (err) {
    //         assert.include(err.toString(), "Status is not locked");
    //     }
    // });













//     it('EOS->WAN inUserRedeem ==> redeem from not the receiver', async () => {
//         try {
//             // accounts[1] is the wan address of the user.
//             //Msg sender is incorrect
//             await htlcInstProxy.inUserRedeem(htlcUserRedeemParams.x);

//         } catch (err) {
//             assert.include(err.toString(), "Msg sender is incorrect");
//         }
//     });

//     it('EOS->WAN inUserRedeem ==> Token manager is null', async () => {
//         try {
//             await crossDelegateNotInit.inUserRedeem(htlcUserRedeemParams.x);
//         } catch (err) {
//             assert.include(err.toString(), "Token manager is null");
//         }
//     });

//     it('EOS->WAN inUserRedeem ==> success', async () => {
//         try {

//             let bnBeforeTotalSupply = new BN(await getTotalSupply(tokenInfo.tokenOrigAccount));
//             let bnAfterTotalSupply = bnBeforeTotalSupply.add(new BN(userMintLockParams.value.toString()));

//             let ret = await htlcInstProxy.inUserRedeem(htlcUserRedeemParams.x, {from: accounts[1]});
//             assert.checkWeb3Event(ret, {
//                 event: 'InboundRedeemLogger',
//                 args: {
//                     wanAddr: accounts[1],
//                     xHash: userMintLockParams.xHash,
//                     x:htlcUserRedeemParams.x,
//                     tokenOrigAccount: tokenInfo.tokenOrigAccount,
//                     storemanGroupPK: userMintLockParams.storemanGroupPK
//                 }
//             });

//             let balance = await getValueFromContract(tokenInfo.tokenOrigAccount, accounts[1]);
//             assert.equal(balance, userMintLockParams.value, "Redeemed token is not equal the locked value");
//         } catch (err) {
//             assert.fail(err);
//         }
//     });

//     it('EOS->WAN inUserRedeem ==> Redeem twice', async () => {
//         try {
//             await htlcInstProxy.inUserRedeem(htlcUserRedeemParams.x, {from: accounts[1]});
//         } catch (err) {
//             assert.include(err.toString(), "Status is not locked");
//         }
//     });

//     it('EOS->WAN inSmgLock  ==>lock value is 0, Value is invalid', async () => {
//         try {
//             // accounts[1] is the wan address of the user.
//             let htlcSmgLockParamsTemp = Object.assign({}, userMintLockParams);
//             htlcSmgLockParamsTemp.wanAddr = accounts[1];
//             htlcSmgLockParamsTemp.value = valueZero;

//             let typeList = PrmTypeList.inSmgLock;
//             let ValueList = buildParametersArray(htlcSmgLockParamsTemp.tokenOrigAccount,
//                 htlcSmgLockParamsTemp.xHash,
//                 htlcSmgLockParamsTemp.wanAddr,
//                 '0x' + htlcSmgLockParamsTemp.value.toString(16));
//             htlcSmgLockParamsTemp.s = schnorr.getS(htlcSmgLockParamsTemp.skSmg, typeList, ValueList);

//             await htlcInstProxy.inSmgLock(htlcSmgLockParamsTemp.tokenOrigAccount,
//                 htlcSmgLockParamsTemp.xHash,
//                 htlcSmgLockParamsTemp.wanAddr,
//                 htlcSmgLockParamsTemp.value,
//                 htlcSmgLockParamsTemp.storemanGroupPK,
//                 htlcSmgLockParamsTemp.r,
//                 htlcSmgLockParamsTemp.s);

//         } catch (err) {
//             assert.include(err.toString(), "Value is invalid");
//         }
//     });

//     it('EOS->WAN inSmgLock  ==>Smg tx is exist', async () => {
//         try {
//             // accounts[1] is the wan address of the user.
//             let htlcSmgLockParamsTemp = Object.assign({}, userMintLockParams);
//             htlcSmgLockParamsTemp.wanAddr = accounts[1];

//             let typeList = PrmTypeList.inSmgLock;
//             let ValueList = buildParametersArray(htlcSmgLockParamsTemp.tokenOrigAccount,
//                 htlcSmgLockParamsTemp.xHash,
//                 htlcSmgLockParamsTemp.wanAddr,
//                 '0x' + htlcSmgLockParamsTemp.value.toString(16));
//             htlcSmgLockParamsTemp.s = schnorr.getS(htlcSmgLockParamsTemp.skSmg, typeList, ValueList);

//             await htlcInstProxy.inSmgLock(htlcSmgLockParamsTemp.tokenOrigAccount,
//                 htlcSmgLockParamsTemp.xHash,
//                 htlcSmgLockParamsTemp.wanAddr,
//                 htlcSmgLockParamsTemp.value,
//                 htlcSmgLockParamsTemp.storemanGroupPK,
//                 htlcSmgLockParamsTemp.r,
//                 htlcSmgLockParamsTemp.s);

//         } catch (err) {
//             assert.include(err.toString(), "Smg tx exists");
//         }
//     });

//     it('EOS->WAN inSmgLock  ==>Quota is not enough', async () => {
//         try {
//             // accounts[1] is the wan address of the user.
//             let htlcSmgLockParamsTemp = Object.assign({}, userMintLockParams);
//             htlcSmgLockParamsTemp.wanAddr = accounts[1];
//             htlcSmgLockParamsTemp.value = v100;
//             htlcSmgLockParamsTemp.xHash = xInfo[3].hash;

//             let typeList = PrmTypeList.inSmgLock;
//             let ValueList = buildParametersArray(htlcSmgLockParamsTemp.tokenOrigAccount,
//                 htlcSmgLockParamsTemp.xHash,
//                 htlcSmgLockParamsTemp.wanAddr,
//                 '0x' + htlcSmgLockParamsTemp.value.toString(16));
//             htlcSmgLockParamsTemp.s = schnorr.getS(htlcSmgLockParamsTemp.skSmg, typeList, ValueList);

//             await htlcInstProxy.inSmgLock(htlcSmgLockParamsTemp.tokenOrigAccount,
//                 htlcSmgLockParamsTemp.xHash,
//                 htlcSmgLockParamsTemp.wanAddr,
//                 htlcSmgLockParamsTemp.value,
//                 htlcSmgLockParamsTemp.storemanGroupPK,
//                 htlcSmgLockParamsTemp.r,
//                 htlcSmgLockParamsTemp.s);

//         } catch (err) {
//             assert.include(err.toString(), "Quota is not enough");
//         }
//     });

//     it('EOS->WAN inUserRedeem ==> Redeem timeout', async () => {
//         try {
//             // smg lock
//             // accounts[1] is the wan address of the user.
//             let htlcSmgLockParamsTemp = Object.assign({}, userMintLockParams);
//             htlcSmgLockParamsTemp.wanAddr = accounts[1];
//             htlcSmgLockParamsTemp.xHash = xInfo[12].hash;
//             htlcSmgLockParamsTemp.x = xInfo[12].x;
//             htlcSmgLockParamsTemp.value = v2;

//             let typeList = PrmTypeList.inSmgLock;
//             let ValueList = buildParametersArray(htlcSmgLockParamsTemp.tokenOrigAccount,
//                 htlcSmgLockParamsTemp.xHash,
//                 htlcSmgLockParamsTemp.wanAddr,
//                 '0x' + htlcSmgLockParamsTemp.value.toString(16));
//             htlcSmgLockParamsTemp.s = schnorr.getS(htlcSmgLockParamsTemp.skSmg, typeList, ValueList);

//             await htlcInstProxy.inSmgLock(htlcSmgLockParamsTemp.tokenOrigAccount,
//                 htlcSmgLockParamsTemp.xHash,
//                 htlcSmgLockParamsTemp.wanAddr,
//                 htlcSmgLockParamsTemp.value,
//                 htlcSmgLockParamsTemp.storemanGroupPK,
//                 htlcSmgLockParamsTemp.r,
//                 htlcSmgLockParamsTemp.s);

//             // wait timeout
//             await sleep(lockedTime + 1);
//             // check user redeem
//             await htlcInstProxy.inUserRedeem(htlcSmgLockParamsTemp.x, {from: accounts[1]});
//         } catch (err) {
//             assert.include(err.toString(), "Redeem timeout");
//         }
//     });

//     it('EOS->WAN inSmgRevoke  ==>Smart contract is halted', async () => {
//         await htlcInstProxy.setHalt(true);
//         try {
//             // accounts[1] is the wan address of the user.
//             let htlcSmgLockParamsTemp = Object.assign({}, userMintLockParams);
//             htlcSmgLockParamsTemp.wanAddr = accounts[1];
//             htlcSmgLockParamsTemp.value = v2;
//             htlcSmgLockParamsTemp.xHash = xInfo[5].hash;

//             await htlcInstProxy.inSmgLock(htlcSmgLockParamsTemp.tokenOrigAccount,
//                 htlcSmgLockParamsTemp.xHash,
//                 htlcSmgLockParamsTemp.wanAddr,
//                 htlcSmgLockParamsTemp.value,
//                 htlcSmgLockParamsTemp.storemanGroupPK,
//                 htlcSmgLockParamsTemp.r,
//                 htlcSmgLockParamsTemp.s);
//         } catch (err) {
//             assert.include(err.toString(), "Smart contract is halted");
//         }
//         await htlcInstProxy.setHalt(false);
//     });

//     it('EOS->WAN inSmgRevoke  ==>should wait for locked time', async () => {
//         try {
//             // accounts[1] is the wan address of the user.
//             let htlcSmgLockParamsTemp = Object.assign({}, userMintLockParams);
//             htlcSmgLockParamsTemp.wanAddr = accounts[1];
//             htlcSmgLockParamsTemp.value = v2;
//             htlcSmgLockParamsTemp.xHash = xInfo[5].hash;

//             let typeList = PrmTypeList.inSmgLock;
//             let ValueList = buildParametersArray(htlcSmgLockParamsTemp.tokenOrigAccount,
//                 htlcSmgLockParamsTemp.xHash,
//                 htlcSmgLockParamsTemp.wanAddr,
//                 '0x' + htlcSmgLockParamsTemp.value.toString(16));
//             htlcSmgLockParamsTemp.s = schnorr.getS(htlcSmgLockParamsTemp.skSmg, typeList, ValueList);

//             await htlcInstProxy.inSmgLock(htlcSmgLockParamsTemp.tokenOrigAccount,
//                 htlcSmgLockParamsTemp.xHash,
//                 htlcSmgLockParamsTemp.wanAddr,
//                 htlcSmgLockParamsTemp.value,
//                 htlcSmgLockParamsTemp.storemanGroupPK,
//                 htlcSmgLockParamsTemp.r,
//                 htlcSmgLockParamsTemp.s);


//             await htlcInstProxy.inSmgRevoke(xInfo[5].hash);
//         } catch (err) {
//             assert.include(err.toString(), "Revoke is not permitted");
//         }
//     });

//     it('EOS->WAN inSmgRevoke  ==>success', async () => {
//         try {
//             await sleep(lockedTime);
//             let ret = await htlcInstProxy.inSmgRevoke(xInfo[5].hash);
//             assert.checkWeb3Event(ret, {
//                 event: 'InboundRevokeLogger',
//                 args: {
//                     xHash: xInfo[5].hash,
//                     tokenOrigAccount: userMintLockParams.tokenOrigAccount,
//                     storemanGroupPK: userMintLockParams.storemanGroupPK
//                 }
//             })
//         } catch (err) {
//             assert.fail(err);
//         }
//     });

//     it('EOS->WAN inSmgRevoke  ==>Status is not locked', async () => {
//         try {
//             await htlcInstProxy.inSmgRevoke(xInfo[5].hash);
//         } catch (err) {
//             assert.include(err.toString(), "Status is not locked");
//         }
//     });

//     it('EOS->WAN inSmgRevoke  ==>Token manager is null', async () => {
//         try {
//             await crossDelegateNotInit.inSmgRevoke(xInfo[5].hash);
//         } catch (err) {
//             assert.include(err.toString(), "Token manager is null");
//         }
//     });

//     it('WAN->EOS outUserLock  ==> Token manager is null', async () => {

//         let error = null;
//         try {
//             // account[0] has no WEOS
//             htlcUserLockParams.userOrigAccount = accounts[3];
//             await crossDelegateNotInit.outUserLock(htlcUserLockParams.xHash,
//                 htlcUserLockParams.value,
//                 tokenInfoNotReg.tokenOrigAccount,
//                 htlcUserLockParams.userOrigAccount,
//                 userMintLockParams.storemanGroupPK);

//         } catch (err) {
//             assert.include(err.toString(), "Token manager is null");
//             error = err;
//         }
//         if (!error) {
//             assert.fail("should catch a error!")
//         }

//     });

//     it('WAN->EOS outUserLock  ==> Smart contract is halted', async () => {
//         await htlcInstProxy.setHalt(true);
//         let error = null;
//         try {
//             // account[0] has no WEOS
//             htlcUserLockParams.userOrigAccount = accounts[3];
//             await htlcInstProxy.outUserLock(htlcUserLockParams.xHash,
//                 htlcUserLockParams.value,
//                 tokenInfoNotReg.tokenOrigAccount,
//                 htlcUserLockParams.userOrigAccount,
//                 userMintLockParams.storemanGroupPK);

//         } catch (err) {
//             assert.include(err.toString(), "Smart contract is halted");
//             error = err;
//         }
//         if (!error) {
//             assert.fail("should catch a error!")
//         }
//         await htlcInstProxy.setHalt(false);
//     });

//     it('WAN->EOS outUserLock  ==> Token is not registered', async () => {
//         let error = null;
//         try {
//             // account[0] has no WEOS
//             htlcUserLockParams.userOrigAccount = accounts[3];
//             await htlcInstProxy.outUserLock(htlcUserLockParams.xHash,
//                 htlcUserLockParams.value,
//                 tokenInfoNotReg.tokenOrigAccount,
//                 htlcUserLockParams.userOrigAccount,
//                 userMintLockParams.storemanGroupPK);

//         } catch (err) {
//             assert.include(err.toString(), "Token is not registered");
//             error = err;
//         }
//         if (!error) {
//             assert.fail("should catch a error!")
//         }
//     });

//     it('WAN->EOS outUserLock  ==> Account has no WEOS', async () => {
//         let error = null;
//         try {
//             // account[0] has no WEOS
//             htlcUserLockParams.userOrigAccount = accounts[3];
//             await htlcInstProxy.outUserLock(htlcUserLockParams.xHash,
//                 htlcUserLockParams.value,
//                 htlcUserLockParams.tokenOrigAccount,
//                 htlcUserLockParams.userOrigAccount,
//                 userMintLockParams.storemanGroupPK);

//         } catch (err) {
//             error = err;
//         }
//         if (!error) {
//             assert.fail("should catch a error!")
//         }
//     });

//     it('WAN->EOS outUserLock  ==> Before lock, No approve', async () => {
//         let error = null;
//         try {

//             htlcUserLockParams.userOrigAccount = accounts[3];
//             await htlcInstProxy.outUserLock(htlcUserLockParams.xHash,
//                 htlcUserLockParams.value,
//                 htlcUserLockParams.tokenOrigAccount,
//                 htlcUserLockParams.userOrigAccount,
//                 userMintLockParams.storemanGroupPK, {from: accounts[1], value: htlcUserLockParams.value});

//         } catch (err) {
//             error = err;
//         }
//         if (!error) {
//             assert.fail("should catch a error!")
//         }
//     });

//     it('WAN->EOS outUserLock  ==> Transferred fee is not enough', async () => {

//         let result = null;
//         try {
//             let balanceBeforeLock = await getValueFromContract(tokenInfo.tokenOrigAccount, accounts[1]);
//             let ret = await tmInstProxy.getTokenInfo(tokenInfo.tokenOrigAccount);
//             //check use has get the WEOS redeemed.
//             let wanTokenSCAddr = ret[3];
//             let wanTokenScInst = await WanToken.at(wanTokenSCAddr);
//             await wanTokenScInst.approve(htlcInstProxy.address, 0, {from: accounts[1]});
//             await wanTokenScInst.approve(htlcInstProxy.address, appproveValue, {from: accounts[1]});
//             let balanceAfterLock = await getValueFromContract(tokenInfo.tokenOrigAccount, accounts[1]);

//             assert.equal(balanceBeforeLock, balanceAfterLock, "Approve should not withdraw the token!");

//             let txFee = (new BN(htlcUserLockParams.value))
//                 .div(new BN(10).pow(new BN(tokenInfo.decimals)))
//                 .mul(new BN(10).pow(new BN(18)))
//                 .mul(new BN(tokenInfo.token2WanRatio))
//                 .mul(new BN(addSmgParams.txFeeRatio))
//                 .div(new BN(DEFAULT_PRECISE))
//                 .div(new BN(DEFAULT_PRECISE));
//             let txFeeNotEnough = txFee.sub(new BN(1));


//             let htlcUserLockParamsTemp = Object.assign({}, htlcUserLockParams);
//             htlcUserLockParamsTemp.xHash = xInfo[10].hash;
//             htlcUserLockParamsTemp.userOrigAccount = accounts[3];

//             await htlcInstProxy.outUserLock(htlcUserLockParamsTemp.xHash,
//                 htlcUserLockParamsTemp.value,
//                 htlcUserLockParamsTemp.tokenOrigAccount,
//                 htlcUserLockParamsTemp.userOrigAccount,
//                 htlcUserLockParamsTemp.storemanGroupPK, {from: accounts[1], value: txFeeNotEnough});

//         } catch (err) {
//             result = err;
//             //assert.include(err.toString(),"Transferred fee is not enough");
//         }
//         if (!result) {
//             assert.fail("should Transferred fee is not enough")
//         }
//     });

//     it('WAN->EOS outUserLock  ==> success', async () => {
//         try {
//             //  lock before approve
//             let balanceBeforeLock = await getValueFromContract(tokenInfo.tokenOrigAccount, accounts[1]);
//             let ret = await tmInstProxy.getTokenInfo(tokenInfo.tokenOrigAccount);
//             //check use has get the WEOS redeemed.
//             let wanTokenSCAddr = ret[3];
//             let wanTokenScInst = await WanToken.at(wanTokenSCAddr);

//             await wanTokenScInst.approve(htlcInstProxy.address, 0, {from: accounts[1]});
//             await wanTokenScInst.approve(htlcInstProxy.address, appproveValue, {from: accounts[1]});
//             let balanceAfterLock = await getValueFromContract(tokenInfo.tokenOrigAccount, accounts[1]);
//             assert.equal(balanceBeforeLock, balanceAfterLock, "Approve should not withdraw the token!");

//             let txFee = (new BN(htlcUserLockParams.value))
//                 .div(new BN(10).pow(new BN(tokenInfo.decimals)))
//                 .mul(new BN(10).pow(new BN(18)))
//                 .mul(new BN(tokenInfo.token2WanRatio))
//                 .mul(new BN(addSmgParams.txFeeRatio))
//                 .div(new BN(DEFAULT_PRECISE))
//                 .div(new BN(DEFAULT_PRECISE));

//             //console.log("txFee:"+txFee.toString());
//             let htlcUserLockParamsTemp = Object.assign({}, htlcUserLockParams);
//             htlcUserLockParamsTemp.userOrigAccount = accounts[3];

//             let beforeCoin = await web3.eth.getBalance(accounts[1]);
//             //console.log("beforeCoin:"+beforeCoin);

//             let txLockRpt = await htlcInstProxy.outUserLock(htlcUserLockParamsTemp.xHash,
//                 htlcUserLockParamsTemp.value,
//                 htlcUserLockParamsTemp.tokenOrigAccount,
//                 htlcUserLockParamsTemp.userOrigAccount,
//                 htlcUserLockParamsTemp.storemanGroupPK, {from: accounts[1], value: htlcUserLockParams.value});

//             ret = txLockRpt;
//             assert.checkWeb3Event(ret, {
//                 event: 'OutboundLockLogger',
//                 args: {
//                     xHash: htlcUserLockParamsTemp.xHash,
//                     value: htlcUserLockParamsTemp.value.toString(),
//                     tokenOrigAccount: htlcUserLockParamsTemp.tokenOrigAccount,
//                     userOrigAccount:htlcUserLockParamsTemp.userOrigAccount.toString().toLowerCase(),
//                     storemanGroupPK: htlcUserLockParamsTemp.storemanGroupPK
//                 }
//             });

//             //console.log(txLockRpt);
//             let txLock = await web3.eth.getTransaction(txLockRpt.tx);
//             //console.log(txLock);

//             //console.log("gasUsed:"+txLockRpt.receipt.gasUsed);
//             //console.log("gasPrice:"+txLock.gasPrice);
//             let AfterCoin = await web3.eth.getBalance(accounts[1]);
//             //console.log("AfterCoin:"+AfterCoin);

//             // beforeCoin-AfterCoin = txFee + gasUsed*gasPrice
//             // check coin
//             let bnGasCoin = new BN(txLockRpt.receipt.gasUsed).mul(new BN(txLock.gasPrice));
//             let bnCoinUsed = bnGasCoin.add(txFee);

//             balanceAfterLock = await getValueFromContract(tokenInfo.tokenOrigAccount, accounts[1]);

//             assert.equal((new BN(beforeCoin).sub(new BN(AfterCoin))).toString(),
//                 bnCoinUsed.toString(),
//                 "After lock, the balance of coin is not right!");
//             // check token
//             assert.equal(balanceAfterLock,
//                 (new BN(balanceBeforeLock).sub(new BN(htlcUserLockParams.value))).toString(),
//                 "After lock, the balance of token is not right!")
//         } catch (err) {
//             assert.fail(err);
//         }
//     });

//     it('WAN->EOS outUserLock  User tx is exist==> ', async () => {
//         try {
//             //  lock before approve
//             let balanceBeforeLock = await getValueFromContract(tokenInfo.tokenOrigAccount, accounts[1]);
//             let ret = await tmInstProxy.getTokenInfo(tokenInfo.tokenOrigAccount);
//             //check use has get the WEOS redeemed.
//             let wanTokenSCAddr = ret[3];
//             let wanTokenScInst = await WanToken.at(wanTokenSCAddr);

//             await wanTokenScInst.approve(htlcInstProxy.address, 0, {from: accounts[1]});
//             await wanTokenScInst.approve(htlcInstProxy.address, appproveValue, {from: accounts[1]});
//             let balanceAfterLock = await getValueFromContract(tokenInfo.tokenOrigAccount, accounts[1]);
//             assert.equal(balanceBeforeLock, balanceAfterLock, "Approve should not withdraw the token!");

//             let txFee = (new BN(htlcUserLockParams.value))
//                 .div(new BN(10).pow(new BN(tokenInfo.decimals)))
//                 .mul(new BN(10).pow(new BN(18)))
//                 .mul(new BN(tokenInfo.token2WanRatio))
//                 .mul(new BN(addSmgParams.txFeeRatio))
//                 .div(new BN(DEFAULT_PRECISE))
//                 .div(new BN(DEFAULT_PRECISE));

//             let htlcUserLockParamsTemp = Object.assign({}, htlcUserLockParams);
//             htlcUserLockParamsTemp.userOrigAccount = accounts[3];
//             await htlcInstProxy.outUserLock(htlcUserLockParamsTemp.xHash,
//                 htlcUserLockParamsTemp.value,
//                 htlcUserLockParamsTemp.tokenOrigAccount,
//                 htlcUserLockParamsTemp.userOrigAccount,
//                 htlcUserLockParamsTemp.storemanGroupPK, {from: accounts[1], value: htlcUserLockParams.value});
//         } catch (err) {
//             assert.include(err.toString(), "User tx exists");
//         }
//     });

//     it('WAN->EOS outUserLock lock value 0, Value is invalid', async () => {
//         try {
//             let htlcUserLockParamsTemp = Object.assign({}, htlcUserLockParams);
//             //  lock before approve
//             let balanceBeforeLock = await getValueFromContract(tokenInfo.tokenOrigAccount, accounts[1]);
//             let ret = await tmInstProxy.getTokenInfo(tokenInfo.tokenOrigAccount);
//             //check use has get the WEOS redeemed.
//             let wanTokenSCAddr = ret[3];
//             let wanTokenScInst = await WanToken.at(wanTokenSCAddr);

//             await wanTokenScInst.approve(htlcInstProxy.address, 0, {from: accounts[1]});
//             await wanTokenScInst.approve(htlcInstProxy.address, appproveValue, {from: accounts[1]});
//             let balanceAfterLock = await getValueFromContract(tokenInfo.tokenOrigAccount, accounts[1]);
//             assert.equal(balanceBeforeLock, balanceAfterLock, "Approve should not withdraw the token!");

//             htlcUserLockParamsTemp.value = valueZero;
//             let txFee = (new BN(htlcUserLockParamsTemp.value))
//                 .div(new BN(10).pow(new BN(tokenInfo.decimals)))
//                 .mul(new BN(10).pow(new BN(18)))
//                 .mul(new BN(tokenInfo.token2WanRatio))
//                 .mul(new BN(addSmgParams.txFeeRatio))
//                 .div(new BN(DEFAULT_PRECISE))
//                 .div(new BN(DEFAULT_PRECISE));

//             htlcUserLockParamsTemp.userOrigAccount = accounts[3];
//             await htlcInstProxy.outUserLock(htlcUserLockParamsTemp.xHash,
//                 htlcUserLockParamsTemp.value,
//                 htlcUserLockParamsTemp.tokenOrigAccount,
//                 htlcUserLockParamsTemp.userOrigAccount,
//                 htlcUserLockParamsTemp.storemanGroupPK, {from: accounts[1], value: htlcUserLockParamsTemp.value});
//         } catch (err) {
//             assert.include(err.toString(), "Value is invalid");
//         }
//     });

//     it('WAN->EOS outSmgRedeem ==> Smart contract is halted', async () => {
//         await htlcInstProxy.setHalt(true);
//         try {
//             htlcSmgRedeemParams.x = xInfo[1].x;
//             await htlcInstProxy.outSmgRedeem(htlcSmgRedeemParams.x);
//         } catch (err) {
//             assert.include(err.toString(), "Smart contract is halted");
//         }
//         await htlcInstProxy.setHalt(false);
//     });

//     it('WAN->EOS outSmgRedeem ==> Token manager is null', async () => {

//         try {
//             htlcSmgRedeemParams.x = xInfo[1].x;
//             await crossDelegateNotInit.outSmgRedeem(htlcSmgRedeemParams.x);
//         } catch (err) {
//             assert.include(err.toString(), "Token manager is null");
//         }

//     });

//     it('WAN->EOS outSmgRedeem ==> use wrong x', async () => {
//         try {
//             htlcSmgRedeemParams.x = xInfo[1].x;
//             await htlcInstProxy.outSmgRedeem(htlcSmgRedeemParams.x);
//         } catch (err) {
//             assert.include(err.toString(), "not locked");
//         }
//     });

//     it('WAN->EOS outSmgRedeem ==> Success', async () => {
//         try {
//             let htlcSmgRedeemParamsTemp = Object.assign({}, htlcSmgRedeemParams);
//             htlcSmgRedeemParamsTemp.x = xInfo[2].x;

//             let typeList = PrmTypeList.outSmgRedeem;
//             let ValueList = buildParametersArray(htlcSmgRedeemParamsTemp.x);
//             htlcSmgRedeemParamsTemp.s = schnorr.getS(skInfo.smg1, typeList, ValueList);

//             let bnBeforeTotalSupply = new BN(await getTotalSupply(tokenInfo.tokenOrigAccount));
//             let bnAfterTotalSupply = bnBeforeTotalSupply.sub(new BN(userMintLockParams.value.toString()));
//             let smgFeeBefore = await htlcInstProxy.getStoremanFee(storemanPK1);

//             let ret = await htlcInstProxy.outSmgRedeem(htlcSmgRedeemParamsTemp.x);

//             let txFee = (new BN(htlcUserLockParams.value))
//                 .div(new BN(10).pow(new BN(tokenInfo.decimals)))
//                 .mul(new BN(10).pow(new BN(18)))
//                 .mul(new BN(tokenInfo.token2WanRatio))
//                 .mul(new BN(addSmgParams.txFeeRatio))
//                 .div(new BN(DEFAULT_PRECISE))
//                 .div(new BN(DEFAULT_PRECISE));

//             assert.checkWeb3Event(ret, {
//                 event: 'OutboundRedeemLogger',
//                 args: {
//                     hashX: xInfo[2].hash,
//                     x: xInfo[2].x,
//                     tokenOrigAccount: userMintLockParams.tokenOrigAccount,
//                     fee: txFee.toString()
//                 }
//             });

//             let smgFeeAfter = await htlcInstProxy.getStoremanFee(storemanPK1);
//             assert.equal(smgFeeAfter.toString(), new BN(smgFeeBefore).add(new BN(txFee)).toString(), "outSmgRedeem fee not right");

//         } catch (err) {
//             assert.fail(err);
//         }
//     });

//     it('WAN->EOS outSmgRedeem ==> Redeem timeout', async () => {
//         try {
//             //  lock before approve
//             let balanceBeforeLock = await getValueFromContract(tokenInfo.tokenOrigAccount, accounts[1]);
//             let ret = await tmInstProxy.getTokenInfo(tokenInfo.tokenOrigAccount);
//             //check use has get the WEOS redeemed.
//             let wanTokenSCAddr = ret[3];
//             let wanTokenScInst = await WanToken.at(wanTokenSCAddr);

//             // approve
//             await wanTokenScInst.approve(htlcInstProxy.address, 0, {from: accounts[1]});
//             await wanTokenScInst.approve(htlcInstProxy.address, appproveValue, {from: accounts[1]});
//             let balanceAfterLock = await getValueFromContract(tokenInfo.tokenOrigAccount, accounts[1]);
//             assert.equal(balanceBeforeLock, balanceAfterLock, "Approve should not withdraw the token!");

//             let txFee = (new BN(htlcUserLockParams.value))
//                 .div(new BN(10).pow(new BN(tokenInfo.decimals)))
//                 .mul(new BN(10).pow(new BN(18)))
//                 .mul(new BN(tokenInfo.token2WanRatio))
//                 .mul(new BN(addSmgParams.txFeeRatio))
//                 .div(new BN(DEFAULT_PRECISE))
//                 .div(new BN(DEFAULT_PRECISE));

//             let htlcUserLockParamsTemp = Object.assign({}, htlcUserLockParams);
//             htlcUserLockParamsTemp.userOrigAccount = accounts[3];
//             htlcUserLockParamsTemp.value = v5;
//             htlcUserLockParamsTemp.xHash = xInfo[13].hash;
//             htlcUserLockParamsTemp.x = xInfo[13].x;

//             await htlcInstProxy.outUserLock(htlcUserLockParamsTemp.xHash,
//                 htlcUserLockParamsTemp.value,
//                 htlcUserLockParamsTemp.tokenOrigAccount,
//                 htlcUserLockParamsTemp.userOrigAccount,
//                 htlcUserLockParamsTemp.storemanGroupPK, {from: accounts[1], value: htlcUserLockParamsTemp.value});

//             await sleep(2 * lockedTime + 1);

//             let htlcSmgRedeemParamsTemp = Object.assign({}, htlcSmgRedeemParams);
//             htlcSmgRedeemParamsTemp.x = xInfo[13].x;

//             await htlcInstProxy.outSmgRedeem(htlcSmgRedeemParamsTemp.x);

//         } catch (err) {
//             assert.include(err.toString(), "Redeem timeout");
//         }
//     });

//     it('WAN->EOS outSmgRedeem ==> redeem twice, Status is not locked', async () => {
//         try {

//             let htlcSmgRedeemParamsTemp = Object.assign({}, htlcSmgRedeemParams);
//             htlcSmgRedeemParamsTemp.x = xInfo[2].x;

//             await htlcInstProxy.outSmgRedeem(htlcSmgRedeemParamsTemp.x);

//         } catch (err) {
//             assert.include(err.toString(), "Status is not locked");
//         }
//     });

//     it('WAN->EOS outUserRevoke  ==>should wait 2*lockedTime,not wait', async () => {
//         let htlcUserLockParamsTemp;
//         try {
//             //  lock before approve
//             let balanceBeforeLock = await getValueFromContract(tokenInfo.tokenOrigAccount, accounts[1]);
//             let ret = await tmInstProxy.getTokenInfo(tokenInfo.tokenOrigAccount);
//             //check use has get the WEOS redeemed.
//             let wanTokenSCAddr = ret[3];
//             let wanTokenScInst = await WanToken.at(wanTokenSCAddr);

//             await wanTokenScInst.approve(htlcInstProxy.address, 0, {from: accounts[1]});
//             await wanTokenScInst.approve(htlcInstProxy.address, appproveValue, {from: accounts[1]});
//             let balanceAfterLock = await getValueFromContract(tokenInfo.tokenOrigAccount, accounts[1]);

//             assert.equal(balanceBeforeLock, balanceAfterLock, "Approve should not withdraw the token!");
//             // lock
//             htlcUserLockParams.userOrigAccount = accounts[3];

//             htlcUserLockParamsTemp = Object.assign({}, htlcUserLockParams);
//             htlcUserLockParamsTemp.xHash = xInfo[4].hash;
//             htlcUserLockParamsTemp.value = v3;
//             await htlcInstProxy.outUserLock(htlcUserLockParamsTemp.xHash,
//                 htlcUserLockParamsTemp.value,
//                 htlcUserLockParamsTemp.tokenOrigAccount,
//                 htlcUserLockParamsTemp.userOrigAccount,
//                 htlcUserLockParamsTemp.storemanGroupPK, {from: accounts[1], value: htlcUserLockParams.value});

//             balanceAfterLock = await getValueFromContract(tokenInfo.tokenOrigAccount, accounts[1]);
//             assert.equal(balanceAfterLock, balanceBeforeLock - htlcUserLockParamsTemp.value, "After lock, the balance is not right!");

//         } catch (err) {
//             assert.fail(err.toString());
//         }

//         // revoke
//         try {
//             await htlcInstProxy.outUserRevoke(htlcUserLockParamsTemp.xHash);
//         } catch (err) {
//             assert.include(err.toString(), "Revoke is not permitted");
//         }
//     });

//     it('WAN->EOS outUserRevoke  ==>Smart contract is halted', async () => {
//         // revoke
//         await htlcInstProxy.setHalt(true);
//         try {
//             await htlcInstProxy.outUserRevoke(xInfo[4].hash);
//         } catch (err) {
//             assert.include(err.toString(), "Smart contract is halted");
//         }
//         await htlcInstProxy.setHalt(false);
//     });

//     it('WAN->EOS outUserRevoke  ==>should wait 2*lockedTime,now only wait lockedTime', async () => {
//         // revoke
//         try {
//             await sleep(lockedTime);
//             await htlcInstProxy.outUserRevoke(xInfo[4].hash);
//         } catch (err) {
//             assert.include(err.toString(), "Revoke is not permitted");
//         }
//     });

//     it('WAN->EOS outUserRevoke  ==>Token manager is null', async () => {
//         // revoke
//         try {
//             await crossDelegateNotInit.outUserRevoke(xInfo[4].hash);
//         } catch (err) {
//             assert.include(err.toString(), "Token manager is null");
//         }
//     });

//     it('Others outUserRevoke  ==>success', async () => {
//         // revoke
//         try {
//             let ret = await htlcInstProxy.getEconomics();
//             //console.log("revokeRatio[org]:"+ret[2].toString());
//             await htlcInstProxy.setEconomics(ret[0],ret[1],revokeFeeRatio);
//             //console.log("revokeRatio[new]:"+revokeFeeRatio.toString());

//             await sleep(2 * lockedTime);
//             let balanceBeforeRevoke = await getValueFromContract(tokenInfo.tokenOrigAccount, accounts[1]);
//             let beforeCoin = await web3.eth.getBalance(accounts[1]);
//             let smgFeeBefore = await htlcInstProxy.getStoremanFee(storemanPK1);
//             //console.log("beforeCoin:"+beforeCoin.toString());

//             let txRevokeRpt = await htlcInstProxy.outUserRevoke(xInfo[4].hash, {from:accounts[1]});



//             let txRevoke = await web3.eth.getTransaction(txRevokeRpt.tx);

//             let balanceAfterRevoke = await getValueFromContract(tokenInfo.tokenOrigAccount, accounts[1]);
//             let afterCoin = await web3.eth.getBalance(accounts[1]);
//             let smgFeeAfter = await htlcInstProxy.getStoremanFee(storemanPK1);
//             //console.log("afterCoin:"+afterCoin.toString());

//             //check token
//             assert.equal(balanceAfterRevoke, (new BN(balanceBeforeRevoke)).add(v3), "The balance of revoked is not right!");


//             let txLockFee = (new BN(v3))
//                 .div(new BN(10).pow(new BN(tokenInfo.decimals)))
//                 .mul(new BN(10).pow(new BN(18)))
//                 .mul(new BN(tokenInfo.token2WanRatio))
//                 .mul(new BN(addSmgParams.txFeeRatio))
//                 .div(new BN(DEFAULT_PRECISE))
//                 .div(new BN(DEFAULT_PRECISE));

//             let txRevokeFee = txLockFee.mul(new BN(revokeFeeRatio)).div(new BN(DEFAULT_PRECISE));
//             let returnCoin = txLockFee.sub(txRevokeFee);

//             ret = txRevokeRpt;
//             assert.checkWeb3Event(ret, {
//                 event: 'OutboundRevokeLogger',
//                 args: {
//                     wanAddr: accounts[1],
//                     xHash: xInfo[4].hash,
//                     tokenOrigAccount: tokenInfo.tokenOrigAccount,
//                     revokeFee: txRevokeFee.toString()
//                 }
//             });

//             // check coin
//             let bnGasCoin = new BN(txRevokeRpt.receipt.gasUsed).mul(new BN(txRevoke.gasPrice));

//             //console.log("bnCoinUsed:"+bnGasCoin.toString());
//             let afterCoinExpect = new BN(beforeCoin).add(returnCoin).sub(bnGasCoin);

//             assert.equal(afterCoin.toString(),
//                 afterCoinExpect.toString(),
//                 "After lock, the balance of coin is not right!");

//             assert.equal(smgFeeAfter.toString(), new BN(smgFeeBefore).add(new BN(txRevokeFee)).toString(), "outUserRevoke fee not right");
//         } catch (err) {
//             assert.fail(err.toString());
//         }
//     });

//     it('Others outUserRevoke  ==>Status is not locked', async () => {
//         // revoke
//         try {
//             let balanceBeforeRevoke = await getValueFromContract(tokenInfo.tokenOrigAccount, accounts[1]);
//             await htlcInstProxy.outUserRevoke(xInfo[4].hash);
//             let balanceAfterRevoke = await getValueFromContract(tokenInfo.tokenOrigAccount, accounts[1]);
//             assert.equal(balanceAfterRevoke, (new BN(balanceBeforeRevoke)).add(v3), "The balance of revoked is not right!");
//         } catch (err) {
//             assert.include(err.toString(), "Status is not locked");
//         }
//     });

//     it('Other addStoremanGroup  ==>Only storeman group admin sc can call it', async () => {
//         try {
//             await htlcInstProxy.addStoremanGroup(tokenInfo.tokenOrigAccount, storemanPK1, quota2, txFeeRatio1);
//         } catch (err) {
//             assert.include(err.toString(), "Only storeman group admin sc can call it");
//         }
//     });

//     it('Other deactivateStoremanGroup  ==>Only storeman group admin sc can call it', async () => {
//         try {
//             await htlcInstProxy.deactivateStoremanGroup(tokenInfo.tokenOrigAccount, storemanPK1);
//         } catch (err) {
//             assert.include(err.toString(), "Only storeman group admin sc can call it");
//         }
//     });

//     it('Other delStoremanGroup  ==>Only storeman group admin sc can call it', async () => {
//         try {
//             await htlcInstProxy.delStoremanGroup(tokenInfo.tokenOrigAccount, storemanPK1);
//         } catch (err) {
//             assert.include(err.toString(), "Only storeman group admin sc can call it");
//         }
//     });

//     it('Other smgAppendQuota  ==>Only storeman group admin sc can call it', async () => {
//         try {
//             await htlcInstProxy.updateStoremanGroup(tokenInfo.tokenOrigAccount, storemanPK1, quota2);
//         } catch (err) {
//             assert.include(err.toString(), "Only storeman group admin sc can call it");
//         }
//     });

//     it('Other deactivateStoremanGroup  ==>Sender must be delegate', async () => {
//         try {
//             await smgInst.storemanGroupUnregister(tokenInfo.tokenOrigAccount, storemanPK1);
//         } catch (err) {
//             assert.include(err.toString(), "Sender must be delegate");
//         }
//     });

//     it('Other delStoremanGroup  ==>Sender must be delegate', async () => {
//         try {
//             await smgInst.storemanGroupWithdrawDeposit(tokenInfo.tokenOrigAccount, storemanPK1);
//         } catch (err) {
//             assert.include(err.toString(), "Sender must be delegate");
//         }
//     });

//     it('Other deactivateStoremanGroup  ==>success', async () => {
//         try {
//             await smgInstProxy.storemanGroupUnregister(tokenInfo.tokenOrigAccount, storemanPK1);
//         } catch (err) {
//             assert.include(err.toString(), "Sender must be delegate");
//         }
//     });

//     it('Other storemanGroupWithdrawDeposit  ==>success', async () => {
//         try {
//             await smgInstProxy.storemanGroupWithdrawDeposit(tokenInfo.tokenOrigAccount, storemanPK1);
//         } catch (err) {
//             assert.include(err.toString(), "Sender must be delegate");
//         }
//     });

//     it('Other storemanGroupUnregister  ==> storemanGroupUnregister success', async () => {
//         try {
//             await smgInstProxy.storemanGroupUnregister(tokenInfo.tokenOrigAccount, storemanPK1, {from: accounts[2]});
//         } catch (err) {
//             assert.fail(err.toString());
//         }
//     });

//     it('Other storemanGroupWithdrawDeposit  ==>storemanGroupWithdrawDeposit should wait time.', async () => {
//         try {
//             await smgInstProxy.storemanGroupWithdrawDeposit(tokenInfo.tokenOrigAccount, storemanPK1, {from: accounts[2]});
//         } catch (err) {
//             assert.include(err.toString(), "Must wait until delay time");
//         }
//     });

//     it('Debt  ==>register two storeman group for debt', async () => {
//         try {
//             let addSmgParamsTemp = Object.assign({}, addSmgParams);
//             addSmgParamsTemp.storemanGroupPK = srcDebtStoremanPK;
//             // source storman
//             await smgInstProxy.storemanGroupRegister(addSmgParamsTemp.tokenOrigAccount,
//                 addSmgParamsTemp.storemanGroupPK,
//                 addSmgParamsTemp.txFeeRatio, {from: accounts[4], value: tokenInfo.minDeposit});

//             // destination storman
//             addSmgParamsTemp.storemanGroupPK = dstDebtStoremanPK;
//             await smgInstProxy.storemanGroupRegister(addSmgParamsTemp.tokenOrigAccount,
//                 addSmgParamsTemp.storemanGroupPK,
//                 addSmgParamsTemp.txFeeRatio, {from: accounts[6], value: tokenInfo.minDeposit});

//         } catch (err) {
//             assert.fail(err.toString());
//         }
//     });

//     it('Debt  ==>inDebtLock Smart contract is halted', async () => {
//         await htlcInstProxy.setHalt(true);
//         let htlcDebtLockParamsTemp = Object.assign({}, htlcDebtLockParams);
//         try {
//             await htlcInstProxy.inDebtLock(tokenInfoNotReg.tokenOrigAccount,
//                 htlcDebtLockParamsTemp.xHash,
//                 htlcDebtLockParamsTemp.srcStoremanPK,
//                 htlcDebtLockParamsTemp.value,
//                 htlcDebtLockParamsTemp.dstStoremanPK,
//                 htlcDebtLockParamsTemp.r,
//                 htlcDebtLockParamsTemp.s);

//         } catch (err) {
//             assert.include(err.toString(), "Smart contract is halted");
//         }
//         await htlcInstProxy.setHalt(false);
//     });

//     it('Debt  ==>inDebtLock Token is not registered', async () => {
//         let htlcDebtLockParamsTemp = Object.assign({}, htlcDebtLockParams);
//         try {

//             await htlcInstProxy.inDebtLock(tokenInfoNotReg.tokenOrigAccount,
//                 htlcDebtLockParamsTemp.xHash,
//                 htlcDebtLockParamsTemp.srcStoremanPK,
//                 htlcDebtLockParamsTemp.value,
//                 htlcDebtLockParamsTemp.dstStoremanPK,
//                 htlcDebtLockParamsTemp.r,
//                 htlcDebtLockParamsTemp.s);

//         } catch (err) {
//             assert.include(err.toString(), "Token is not registered");
//         }

//     });

//     it('Debt  ==>inDebtLock Token manager is null', async () => {
//         let htlcDebtLockParamsTemp = Object.assign({}, htlcDebtLockParams);
//         try {

//             await crossDelegateNotInit.inDebtLock(tokenInfoNotReg.tokenOrigAccount,
//                 htlcDebtLockParamsTemp.xHash,
//                 htlcDebtLockParamsTemp.srcStoremanPK,
//                 htlcDebtLockParamsTemp.value,
//                 htlcDebtLockParamsTemp.dstStoremanPK,
//                 htlcDebtLockParamsTemp.r,
//                 htlcDebtLockParamsTemp.s);

//         } catch (err) {
//             assert.include(err.toString(), "Token manager is null");
//         }

//     });

//     it('Debt  ==>inDebtLock PK is active should deactive', async () => {
//         let htlcDebtLockParamsTemp = Object.assign({}, htlcDebtLockParams);
//         try {

//             let typeList = PrmTypeList.inDebtLock;
//             let ValueList = buildParametersArray(tokenInfo.tokenOrigAccount,
//                 htlcDebtLockParamsTemp.xHash,
//                 htlcDebtLockParamsTemp.srcStoremanPK,
//                 '0x' + htlcDebtLockParamsTemp.value.toString(16));
//             htlcDebtLockParamsTemp.s = schnorr.getS(htlcDebtLockParamsTemp.skInfo.dstSmg, typeList, ValueList);

//             await htlcInstProxy.inDebtLock(tokenInfo.tokenOrigAccount,
//                 htlcDebtLockParamsTemp.xHash,
//                 htlcDebtLockParamsTemp.srcStoremanPK,
//                 htlcDebtLockParamsTemp.value,
//                 htlcDebtLockParamsTemp.dstStoremanPK,
//                 htlcDebtLockParamsTemp.r,
//                 htlcDebtLockParamsTemp.s);

//         } catch (err) {
//             assert.include(err.toString(), "PK is active");
//         }

//     });

//     it('Debt  ==>inDebtLock success', async () => {
//         let htlcDebtLockParamsTemp = Object.assign({}, htlcDebtLockParams);
//         try {

//             // accounts[1] is the wan address of the user.
//             // lock
//             let htlcSmgLockParamsTemp = Object.assign({}, userMintLockParams);
//             htlcSmgLockParamsTemp.wanAddr = accounts[1];
//             htlcSmgLockParamsTemp.xHash = xInfo[7].hash;
//             htlcSmgLockParamsTemp.storemanGroupPK = srcDebtStoremanPK;
//             htlcSmgLockParamsTemp.value = v3;

//             let typeList = PrmTypeList.inSmgLock;
//             let ValueList = buildParametersArray(htlcSmgLockParamsTemp.tokenOrigAccount,
//                 htlcSmgLockParamsTemp.xHash,
//                 htlcSmgLockParamsTemp.wanAddr,
//                 '0x' + htlcSmgLockParamsTemp.value.toString(16));
//             htlcSmgLockParamsTemp.s = schnorr.getS(skInfo.srcSmg, typeList, ValueList);

//             await htlcInstProxy.inSmgLock(htlcSmgLockParamsTemp.tokenOrigAccount,
//                 htlcSmgLockParamsTemp.xHash,
//                 htlcSmgLockParamsTemp.wanAddr,
//                 htlcSmgLockParamsTemp.value,
//                 htlcSmgLockParamsTemp.storemanGroupPK,
//                 htlcSmgLockParamsTemp.r,
//                 htlcSmgLockParamsTemp.s);

//             // redeem
//             let htlcUserRedeemParamsTemp = Object.assign({}, htlcUserRedeemParams);
//             htlcUserRedeemParamsTemp.x = xInfo[7].x;
//             await htlcInstProxy.inUserRedeem(htlcUserRedeemParamsTemp.x, {from: accounts[1]});

//             let srcQuata = await queryStoremanGroupQuota(tokenInfo.tokenOrigAccount, htlcDebtLockParamsTemp.srcStoremanPK);
//             let dstQuata = await queryStoremanGroupQuota(tokenInfo.tokenOrigAccount, htlcDebtLockParamsTemp.dstStoremanPK);

//             // deactive
//             await smgInstProxy.storemanGroupUnregister(tokenInfo.tokenOrigAccount, srcDebtStoremanPK, {from: accounts[4]});

//             // debtLock
//             htlcDebtLockParamsTemp.value = v4;

//             let typeList1 = PrmTypeList.inDebtLock;
//             let ValueList1 = buildParametersArray(tokenInfo.tokenOrigAccount,
//                 htlcDebtLockParamsTemp.xHash,
//                 htlcDebtLockParamsTemp.srcStoremanPK,
//                 '0x' + htlcDebtLockParamsTemp.value.toString(16));
//             htlcDebtLockParamsTemp.s = schnorr.getS(htlcDebtLockParamsTemp.skInfo.dstSmg, typeList1, ValueList1);

//             let ret = await htlcInstProxy.inDebtLock(tokenInfo.tokenOrigAccount,
//                 htlcDebtLockParamsTemp.xHash,
//                 htlcDebtLockParamsTemp.srcStoremanPK,
//                 htlcDebtLockParamsTemp.value,
//                 htlcDebtLockParamsTemp.dstStoremanPK,
//                 htlcDebtLockParamsTemp.r,
//                 htlcDebtLockParamsTemp.s);

//             assert.checkWeb3Event(ret, {
//                 event: 'DebtLockLogger',
//                 args: {
//                     xHash: htlcDebtLockParamsTemp.xHash,
//                     value: htlcDebtLockParamsTemp.value.toString(),
//                     tokenOrigAccount: tokenInfo.tokenOrigAccount,
//                     srcStoremanPK: htlcDebtLockParamsTemp.srcStoremanPK,
//                     dstStoremanPK:htlcDebtLockParamsTemp.dstStoremanPK
//                 }
//             });
//             srcQuata = await queryStoremanGroupQuota(tokenInfo.tokenOrigAccount, htlcDebtLockParamsTemp.srcStoremanPK);
//             dstQuata = await queryStoremanGroupQuota(tokenInfo.tokenOrigAccount, htlcDebtLockParamsTemp.dstStoremanPK);

//         } catch (err) {
//             assert.fail(err.toString());
//         }

//     });

//     it('Debt  ==>inDebtRedeem success', async () => {

//         let htlcDebtRedeemParamsTemp = Object.assign({}, htlcDebtRedeemParams);
//         try {

//             let typeList = PrmTypeList.inDebtRedeem;
//             let ValueList = buildParametersArray(htlcDebtRedeemParamsTemp.x);
//             htlcDebtRedeemParamsTemp.s = schnorr.getS(htlcDebtRedeemParamsTemp.skSmg, typeList, ValueList);

//             let ret = await htlcInstProxy.inDebtRedeem(htlcDebtRedeemParamsTemp.x);

//             assert.checkWeb3Event(ret, {
//                 event: 'DebtRedeemLogger',
//                 args: {
//                     xHash: htlcDebtLockParams.xHash,
//                     x:htlcDebtRedeemParamsTemp.x,
//                     tokenOrigAccount: tokenInfo.tokenOrigAccount,
//                     srcStoremanPK: htlcDebtLockParams.srcStoremanPK,
//                     dstStoremanPK:htlcDebtLockParams.dstStoremanPK
//                 }
//             });

//         } catch (err) {
//             assert.fail(err.toString());
//         }
//     });

//     it('Debt  ==>inDebtRedeem redeem twice Status is not locked', async () => {

//         let htlcDebtRedeemParamsTemp = Object.assign({}, htlcDebtRedeemParams);
//         try {
//             await htlcInstProxy.inDebtRedeem(htlcDebtRedeemParamsTemp.x);

//         } catch (err) {
//             assert.include(err.toString(), "Status is not locked");
//         }
//     });

//     it('Debt  ==>inDebtLock Debt tx is exist', async () => {
//         let htlcDebtLockParamsTemp = Object.assign({}, htlcDebtLockParams);
//         try {
//             let htlcSmgLockParamsTemp = Object.assign({}, userMintLockParams);
//             htlcSmgLockParamsTemp.wanAddr = accounts[1];
//             htlcSmgLockParamsTemp.xHash = xInfo[7].hash;
//             // debtLock
//             htlcDebtLockParamsTemp.value = v4;

//             let typeList = PrmTypeList.inDebtLock;
//             let ValueList = buildParametersArray(tokenInfo.tokenOrigAccount,
//                 htlcDebtLockParamsTemp.xHash,
//                 htlcDebtLockParamsTemp.srcStoremanPK,
//                 '0x' + htlcDebtLockParamsTemp.value.toString(16));
//             htlcDebtLockParamsTemp.s = schnorr.getS(htlcDebtLockParamsTemp.skInfo.dstSmg, typeList, ValueList);

//             await htlcInstProxy.inDebtLock(tokenInfo.tokenOrigAccount,
//                 htlcDebtLockParamsTemp.xHash,
//                 htlcDebtLockParamsTemp.srcStoremanPK,
//                 htlcDebtLockParamsTemp.value,
//                 htlcDebtLockParamsTemp.dstStoremanPK,
//                 htlcDebtLockParamsTemp.r,
//                 htlcDebtLockParamsTemp.s);

//         } catch (err) {
//             assert.include(err.toString(), "Debt tx exists");
//         }

//     });

//     it('Debt  ==>inDebtLock lock value 0, Value is invalid', async () => {
//         let htlcDebtLockParamsTemp = Object.assign({}, htlcDebtLockParams);
//         try {
//             // debtLock
//             //htlcDebtLockParamsTemp.value = v4;
//             htlcDebtLockParamsTemp.value = valueZero;

//             let typeList = PrmTypeList.inDebtLock;
//             let ValueList = buildParametersArray(tokenInfo.tokenOrigAccount,
//                 htlcDebtLockParamsTemp.xHash,
//                 htlcDebtLockParamsTemp.srcStoremanPK,
//                 '0x' + htlcDebtLockParamsTemp.value.toString(16));
//             htlcDebtLockParamsTemp.s = schnorr.getS(htlcDebtLockParamsTemp.skInfo.dstSmg, typeList, ValueList);

//             await htlcInstProxy.inDebtLock(tokenInfo.tokenOrigAccount,
//                 htlcDebtLockParamsTemp.xHash,
//                 htlcDebtLockParamsTemp.srcStoremanPK,
//                 htlcDebtLockParamsTemp.value,
//                 htlcDebtLockParamsTemp.dstStoremanPK,
//                 htlcDebtLockParamsTemp.r,
//                 htlcDebtLockParamsTemp.s);

//         } catch (err) {
//             assert.include(err.toString(), "Value is invalid");
//         }

//     });

//     it('Debt  ==>inDebtRedeem Smart contract is halted', async () => {
//         await htlcInstProxy.setHalt(true);
//         let htlcDebtRedeemParamsTemp = Object.assign({}, htlcDebtRedeemParams);
//         try {
//             await htlcInstProxy.inDebtRedeem(htlcDebtRedeemParamsTemp.x);

//         } catch (err) {
//             assert.include(err.toString(), err.toString(), "Smart contract is halted");
//         }
//         await htlcInstProxy.setHalt(false);
//     });

//     it('Debt  ==>inDebtRedeem Redeem timeout', async () => {
//         try {

//             let htlcDebtLockParamsTemp = Object.assign({}, htlcDebtLockParams);

//             // for redeem timeout
//             htlcDebtLockParamsTemp.value = v5;
//             htlcDebtLockParamsTemp.xHash = xInfo[14].hash;

//             let typeList = PrmTypeList.inDebtLock;
//             let ValueList = buildParametersArray(tokenInfo.tokenOrigAccount,
//                 htlcDebtLockParamsTemp.xHash,
//                 htlcDebtLockParamsTemp.srcStoremanPK,
//                 '0x' + htlcDebtLockParamsTemp.value.toString(16));
//             htlcDebtLockParamsTemp.s = schnorr.getS(htlcDebtLockParamsTemp.skInfo.dstSmg, typeList, ValueList);

//             await htlcInstProxy.inDebtLock(tokenInfo.tokenOrigAccount,
//                 htlcDebtLockParamsTemp.xHash,
//                 htlcDebtLockParamsTemp.srcStoremanPK,
//                 htlcDebtLockParamsTemp.value,
//                 htlcDebtLockParamsTemp.dstStoremanPK,
//                 htlcDebtLockParamsTemp.r,
//                 htlcDebtLockParamsTemp.s);

//             srcQuata = await queryStoremanGroupQuota(tokenInfo.tokenOrigAccount, htlcDebtLockParamsTemp.srcStoremanPK);
//             dstQuata = await queryStoremanGroupQuota(tokenInfo.tokenOrigAccount, htlcDebtLockParamsTemp.dstStoremanPK);

//             let htlcDebtRedeemParamsTemp = Object.assign({}, htlcDebtRedeemParams);
//             htlcDebtRedeemParamsTemp.x = xInfo[14].x;

//             await sleep(lockedTime + 1);

//             let typeList1 = PrmTypeList.inDebtRedeem;
//             let ValueList1 = buildParametersArray(htlcDebtRedeemParamsTemp.x);

//             htlcDebtRedeemParamsTemp.s = schnorr.getS(htlcDebtRedeemParamsTemp.skSmg, typeList1, ValueList1);
//             await htlcInstProxy.inDebtRedeem(htlcDebtRedeemParamsTemp.x);

//         } catch (err) {
//             assert.include(err.toString(), "Redeem timeout");
//         }
//     });

//     it('Debt  ==>inDebtRedeem Token manager is null', async () => {

//         let htlcDebtRedeemParamsTemp = Object.assign({}, htlcDebtRedeemParams);
//         try {
//             await crossDelegateNotInit.inDebtRedeem(htlcDebtRedeemParamsTemp.x);

//         } catch (err) {
//             assert.include(err.toString(), "Token manager is null");
//         }
//     });

//     it('Debt  ==>inDebtRevoke Token manager is null', async () => {

//         try {

//             let htlcDebtLockParamsTemp = Object.assign({}, htlcDebtLockParams);
//             htlcDebtLockParamsTemp.xHash = xInfo[8].hash;
//             await crossDelegateNotInit.inDebtRevoke(htlcDebtLockParamsTemp.xHash);

//         } catch (err) {
//             assert.include(err.toString(), "Token manager is null");
//         }

//     });

//     it('Debt  ==>inDebtRevoke Smart contract is halted', async () => {
//         await htlcInstProxy.setHalt(true);
//         try {

//             let htlcDebtLockParamsTemp = Object.assign({}, htlcDebtLockParams);
//             htlcDebtLockParamsTemp.xHash = xInfo[8].hash;

//             await htlcInstProxy.inDebtLock(tokenInfo.tokenOrigAccount,
//                 htlcDebtLockParamsTemp.xHash,
//                 htlcDebtLockParamsTemp.srcStoremanPK,
//                 htlcDebtLockParamsTemp.value,
//                 htlcDebtLockParamsTemp.dstStoremanPK,
//                 htlcDebtLockParamsTemp.r,
//                 htlcDebtLockParamsTemp.s);

//             await htlcInstProxy.inDebtRevoke(htlcDebtLockParamsTemp.xHash);

//         } catch (err) {
//             assert.include(err.toString(), "Smart contract is halted");
//         }
//         await htlcInstProxy.setHalt(false);
//     });

//     it('Debt  ==>inDebtRevoke Duplicate unregister', async () => {
//         try {

//             let htlcDebtLockParamsTemp = Object.assign({}, htlcDebtLockParams);
//             htlcDebtLockParamsTemp.xHash = xInfo[8].hash;
//             await smgInstProxy.storemanGroupUnregister(tokenInfo.tokenOrigAccount, srcDebtStoremanPK, {from: accounts[4]});

//         } catch (err) {
//             assert.include(err.toString(), "Duplicate unregister");
//         }
//     });

//     it('Debt  ==>inDebtRevoke Revoke is not permitted', async () => {
//         try {
//             // register storeman
//             let addSmgParamsTemp = Object.assign({}, addSmgParams);
//             addSmgParamsTemp.storemanGroupPK = srcDebtStoremanPK1;
//             // source storman
//             await smgInstProxy.storemanGroupRegister(addSmgParamsTemp.tokenOrigAccount,
//                 addSmgParamsTemp.storemanGroupPK,
//                 addSmgParamsTemp.txFeeRatio, {from: accounts[4], value: tokenInfo.minDeposit});

//             // accounts[1] is the wan address of the user.
//             // lock
//             let htlcSmgLockParamsTemp = Object.assign({}, userMintLockParams);
//             htlcSmgLockParamsTemp.wanAddr = accounts[1];
//             htlcSmgLockParamsTemp.xHash = xInfo[9].hash;
//             htlcSmgLockParamsTemp.storemanGroupPK = srcDebtStoremanPK1;
//             htlcSmgLockParamsTemp.value = v4;

//             let typeList = PrmTypeList.inSmgLock;
//             let ValueList = buildParametersArray(htlcSmgLockParamsTemp.tokenOrigAccount,
//                 htlcSmgLockParamsTemp.xHash,
//                 htlcSmgLockParamsTemp.wanAddr,
//                 '0x' + htlcSmgLockParamsTemp.value.toString(16));
//             htlcSmgLockParamsTemp.s = schnorr.getS(skInfo.srcSmg1, typeList, ValueList);

//             await htlcInstProxy.inSmgLock(htlcSmgLockParamsTemp.tokenOrigAccount,
//                 htlcSmgLockParamsTemp.xHash,
//                 htlcSmgLockParamsTemp.wanAddr,
//                 htlcSmgLockParamsTemp.value,
//                 htlcSmgLockParamsTemp.storemanGroupPK,
//                 htlcSmgLockParamsTemp.r,
//                 htlcSmgLockParamsTemp.s);

//             // redeem
//             let htlcUserRedeemParamsTemp = Object.assign({}, htlcUserRedeemParams);
//             htlcUserRedeemParamsTemp.x = xInfo[9].x;
//             await htlcInstProxy.inUserRedeem(htlcUserRedeemParamsTemp.x, {from: accounts[1]});

//             // deactive
//             await smgInstProxy.storemanGroupUnregister(tokenInfo.tokenOrigAccount, srcDebtStoremanPK1, {from: accounts[4]});

//             // debtLock
//             let htlcDebtLockParamsTemp = Object.assign({}, htlcDebtLockParams);
//             htlcDebtLockParamsTemp.srcStoremanPK = srcDebtStoremanPK1;
//             htlcDebtLockParamsTemp.xHash = xInfo[11].hash;
//             htlcDebtLockParamsTemp.value = v4;

//             typeList = PrmTypeList.inDebtLock;
//             ValueList = buildParametersArray(tokenInfo.tokenOrigAccount,
//                 htlcDebtLockParamsTemp.xHash,
//                 htlcDebtLockParamsTemp.srcStoremanPK,
//                 '0x' + htlcDebtLockParamsTemp.value.toString(16));
//             htlcDebtLockParamsTemp.s = schnorr.getS(htlcDebtLockParamsTemp.skInfo.dstSmg, typeList, ValueList);

//             await htlcInstProxy.inDebtLock(tokenInfo.tokenOrigAccount,
//                 htlcDebtLockParamsTemp.xHash,
//                 htlcDebtLockParamsTemp.srcStoremanPK,
//                 htlcDebtLockParamsTemp.value,
//                 htlcDebtLockParamsTemp.dstStoremanPK,
//                 htlcDebtLockParamsTemp.r,
//                 htlcDebtLockParamsTemp.s);

//             await htlcInstProxy.inDebtRevoke(htlcDebtLockParamsTemp.xHash);

//         } catch (err) {
//             assert.include(err.toString(), "Revoke is not permitted");
//         }

//     });

//     it('Debt  ==>inDebtRevoke success', async () => {
//         try {
//             let htlcDebtLockParamsTemp = Object.assign({}, htlcDebtLockParams);
//             htlcDebtLockParamsTemp.xHash = xInfo[11].hash;
//             await sleep(2 * lockedTime);
//             let ret = await htlcInstProxy.inDebtRevoke(htlcDebtLockParamsTemp.xHash);

//             assert.checkWeb3Event(ret, {
//                 event: 'DebtRevokeLogger',
//                 args: {
//                     xHash: htlcDebtLockParamsTemp.xHash,
//                     tokenOrigAccount: tokenInfo.tokenOrigAccount,
//                     srcStoremanPK: srcDebtStoremanPK1,
//                     dstStoremanPK: htlcDebtLockParams.dstStoremanPK
//                 }
//             });

//         } catch (err) {
//             assert.fail(err.toString());
//         }

//     });

//     it('Debt  ==>inDebtRevoke Status is not locked', async () => {
//         try {
//             let htlcDebtLockParamsTemp = Object.assign({}, htlcDebtLockParams);
//             htlcDebtLockParamsTemp.xHash = xInfo[11].hash;
//             await htlcInstProxy.inDebtRevoke(htlcDebtLockParamsTemp.xHash);

//         } catch (err) {
//             assert.include(err.toString(), "Status is not locked");
//         }
//     });

//     it('others  ==>smgWithdrawFee', async () => {
//         try {

//             let typeList = PrmTypeList.smgWithdrawFee;
//             let nowTimeStamp = Math.floor(Date.now()/1000);
//             let bnTimeStamp = '0x'+(new BN(nowTimeStamp).toString(16));
//             let ValueList = buildParametersArray(bnTimeStamp,accounts[6]);
//             let tempS = schnorr.getS(skInfo.dstSmg, typeList, ValueList);

//             let bnSmgFee = new BN(await htlcInstProxy.getStoremanFee(dstDebtStoremanPK));
//             let bnRcvCoin = new BN(await web3.eth.getBalance(accounts[6]));
//             let bnRcvCoinExpect = bnRcvCoin.add(bnSmgFee);
//             let ret= await  htlcInstProxy.smgWithdrawFee(dstDebtStoremanPK,new BN(nowTimeStamp),accounts[6], R, tempS);
//             let bnRcvCoinActual = new BN(await web3.eth.getBalance(accounts[6]));

//             assert.checkWeb3Event(ret, {
//                 event: 'SmgWithdrawFeeLogger',
//                 args: {
//                     receiver: accounts[6],
//                     storemanGroupPK: dstDebtStoremanPK,
//                     timeStamp:(new BN(nowTimeStamp)).toString(),
//                     fee:bnSmgFee.toString()
//                 }
//             });

//             assert.equal(bnRcvCoinExpect.toString(),bnRcvCoinActual.toString());
//         } catch (err) {
//             assert.fail(err.toString());
//         }
//     });

//     it('others  ==>smgWithdrawFee time out', async () => {
//     try {

//       let typeList = PrmTypeList.smgWithdrawFee;
//       let nowTimeStamp = Math.floor(Date.now()/1000);
//       let bnTimeStamp = '0x'+(new BN(nowTimeStamp).toString(16));
//       let ValueList = buildParametersArray(bnTimeStamp,accounts[6]);
//       let tempS = schnorr.getS(skInfo.dstSmg, typeList, ValueList);
//       await sleep(msgRcvTimeout);
//       await  htlcInstProxy.smgWithdrawFee(dstDebtStoremanPK,new BN(nowTimeStamp), accounts[6], R, tempS);
//     } catch (err) {
//       assert.include(err.toString(),"The receiver address expired");
//     }
//   });

});


async function getTotalSupply(tokenOrigAccount) {
    let ret = await tmInstProxy.getTokenInfo(tokenInfo.tokenOrigAccount);
    let wanTokenSCAddr = ret[3];
    let wanTokenScInst = await WanToken.at(wanTokenSCAddr);
    let balance = await wanTokenScInst.totalSupply();
    return balance.toString();
};

async function queryStoremanGroupQuota(tokenOrigAccount, storemanGroupPK) {
    let ret = await htlcInstProxy.queryStoremanGroupQuota(tokenOrigAccount,
        storemanGroupPK);
    let result;
    result = {
        quota: ret[0].toString(),
        inboundQuota: ret[1].toString(),
        outboundQuota: ret[2].toString(),
        receivable: ret[3].toString(),
        payable: ret[4].toString(),
        debt: ret[5].toString(),
    };
    return result;
};

function buildParametersArray(...args) {
    let ret = [];
    for (let arg of args) {
        ret.push(arg);
    }
    return ret;
}

function parseEventsBy(receipt, expectedEvents, filterByName) {
    let events = new Array();

    receipt.logs.forEach(function(logEntry) {
        let expectedEntry = expectedEvents.find(function(evt) {
            return (evt.event === logEntry.event)
        });

        // When filtering, ignore events that are not expected
        if ((! filterByName) || expectedEntry) {
            // Event name
            let event = {
                event: logEntry.event
            };

            // Event arguments
            // Ignore the arguments when they are not tested
            // (ie. expectedEntry.args is undefined)
            if ((! expectedEntry) || (expectedEntry && expectedEntry.args)) {
                event.args = Object.keys(logEntry.args).reduce(function(previous, current) {
                    previous[current] =
                        (typeof logEntry.args[current].toNumber === 'function')
                            ? logEntry.args[current].toString()
                            : logEntry.args[current];
                    // console.log("previous:", previous);
                    return previous;
                }, {});
            }
            // console.log("parseEventsBy:", event);
            events.push(event);
        }
    });

    return events;
}

async function testInit(){
    if (typeof assert !== 'undefined') {
        assert.getWeb3Log = function(receipt, expectedEvent) {
            let entries = receipt.logs.filter(log => log.event === expectedEvent.event);
            if(!entries.length){
                assert.fail("Not get the expected event: event is null");
            }
            let entry = entries[0];
            assert.equal(entry.event, expectedEvent.event);
            return entry;
        };

        assert.checkWeb3Event = function(receipt, expectedEvent, message) {
            // console.log("receipt", receipt);
            // console.log("expectedEvent", expectedEvent);
            let events = parseEventsBy(receipt, [expectedEvent], true);
            let entry = events[0];
            if(entry == null){
                assert.fail("Not get the expected event: event is null");
            }

            // console.log("parsed event", entry);
            assert.equal(entry.event, expectedEvent.event);
            let expectArgs = expectedEvent.args;
            let entryArgs = entry.args;
            let needKeys = Object.keys(expectArgs);
            for(let key of needKeys){
                if(expectArgs[key] != entryArgs[key]){
                    assert.fail("Not get the expected event args: " + key);
                    break;
                }
            }
        };
    }
}
